<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何使用Rest Assured进行RESTful API测试</title>
    <link href="/shinyruotechtips/2024/02/bba85c2d0992/"/>
    <url>/shinyruotechtips/2024/02/bba85c2d0992/</url>
    
    <content type="html"><![CDATA[<h4 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h4><p>随着互联网和移动设备的发展，人们对Web应用的使用需求也增加，传统的动态页面（如JSP）由于低效率而渐渐被HTML+JavaScript(Ajax)的前后端分离所取代，并且安卓、IOS、小程序等形式客户端层出不穷，客户端的种类出现多元化，而客户端和服务端就需要接口进行通信，但接口的规范性是一个问题。</p><p>所以一套结构清晰、符合标准、易于理解、扩展方便让大部分人都能够理解接受的接口风格就显得越来越重要，而RESTful风格的接口(RESTful API)刚好有以上特点，就逐渐被实践应用而变得流行起来，可以参考<a href="https://docs.github.com/en/rest?apiVersion=2022-11-28">GitHub REST API documentation - GitHub Docs</a>的文档对REST API进行学习。</p><p>REST并没有一个明确的标准，而更像是一种设计的风格，满足这种设计风格的程序或接口我们称之为RESTful（从单词字面来看就是一个形容词）。所以RESTful API 就是满足REST架构风格的接口。如果用一句话大概概括一下REST风格，那就是<strong>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</strong> 此处只简单介绍REST API，因为这不是讨论的重点，关于REST API设计规范和限制条件，需要在日常开发中了解学习。</p><h4 id="HTTP请求方法和状态码"><a href="#HTTP请求方法和状态码" class="headerlink" title="HTTP请求方法和状态码"></a>HTTP请求方法和状态码</h4><p>REST API使用五种HTTP方法来发送请求：</p><ul><li>GET：在特定的URL上检索信息。</li><li>PUT：如果资源存在，则更新先前的资源，若不存在，则创建新的信息。</li><li>POST：向服务器发送信息，例如上传数据或创建新的实体。</li><li>DELETE：删除特定URL上的所有当前资源。</li><li>PATCH：用于对资源进行部分更新。</li></ul><p>当使用以上方法发送请求后，客户端会收到数字形式的代码，称为“状态码”，有时也叫“响应码”。然后我们可以根据这些状态码来解读服务器对特定请求发送的响应。状态码主要分为五类，具体如下：</p><ul><li>1xx（100-199）：信息，服务器收到请求，需要请求者继续执行操作</li><li>2xx（200-299）：成功，操作被成功接收并处理</li><li>3xx（300-399）：重定向，需要进一步的操作以完成请求</li><li>4xx（400-499）：客户端错误，请求包含语法错误或无法完成请求</li><li>5xx（500-599）：服务器错误，服务器在处理请求的过程中发生了错误，无法完成请求</li></ul><p>通过以上状态码，我们可以判断应用程序的运行情况。1xx、2xx和3xx状态码通常不被视为错误，而是提供了一些信息性的消息，它们并不会影响用户体验。</p><p>但是，如果收到了4xx或5xx状态码，则表示发生了错误。这意味着用户&#x2F;APP在访问API时可能会遇到错误消息。4xx状态码通常与客户端或浏览器级别的错误相关，而5xx状态码通常表示服务器级别的错误。因此在进行REST API测试时，应该通过检查这些错误代码来评估每个响应的情况。</p><p>有关HTTP协议的具体内容细节，可以查阅。<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">HTTP | MDN (mozilla.org)</a></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>以toolsqa网站的一个demo作为例子，我们可以在这里<a href="https://demoqa.com/swagger/#/BookStore">Swagger UI (demoqa.com)</a>看到该示例提供的一些API，这个例子是一个书店的库存管理系统，提供了多种REST API方法来获取书店中书的信息。</p><p>Swagger 是一个实现了OpenAPI 规范的工具集，SwaggerUI是其生成的文档&#x2F;页面。</p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rest%20Assured%E8%BF%9B%E8%A1%8CRESTful%20API%E6%B5%8B%E8%AF%95/2024-02-21-17-54-42-image.png"></p><p>在SwaggerUI中我们还可以对接口进行执行，这里的GET方法返回的是Books的具体内容。</p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rest%20Assured%E8%BF%9B%E8%A1%8CRESTful%20API%E6%B5%8B%E8%AF%95/2024-02-21-17-56-19-image.png"></p><h4 id="使用Rest-Assured进行REST-API测试"><a href="#使用Rest-Assured进行REST-API测试" class="headerlink" title="使用Rest Assured进行REST API测试"></a>使用Rest Assured进行REST API测试</h4><p>Rest Assured是一个Java库，用于测试RESTful API。它被广泛应用于测试基于JSON和XML的Web应用程序。此外，它完全支持GET、PUT、POST、PATCH和DELETE等所有REST方法。接下来详细介绍如何使用Rest Assured库测试一个REST API。</p><p>要编写一个示例的REST API测试，我们将使用以下REST API链接。</p><ul><li><p>请求URL：<a href="https://demoqa.com/BookStore/v1/Books">https://demoqa.com/BookStore/v1/Books</a></p></li><li><p>HTTP方法：GET</p></li><li><p>备注：此URL将返回书店的库存详情。请求中没有输入参数。</p></li><li><p>响应：{“books”: [{“isbn”: “string”,”title”: “string”,”subTitle”: “string”,”author”:”string”,”publish_date”: “2022-01-25T13:44:50.276Z”,”publisher”: “string”,”pages”: 0,”description”: “string”,”website”: “string”}]}</p></li></ul><p>实际上，如果我们直接在浏览器中打开上述URL，我们会得到如下所示的输出：</p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rest%20Assured%E8%BF%9B%E8%A1%8CRESTful%20API%E6%B5%8B%E8%AF%95/2024-02-26-15-37-48-image.png"></p><p>要使用Rest Assured库以编程方式获取相同的输出，我们需要按照以下步骤操作：</p><ol><li>使用RestAssured类生成一个针对URL的RequestSpecification。</li><li>指定HTTP方法类型（GET方法）。</li><li>将请求发送到服务器。</li><li>从服务器获取响应。</li><li>打印返回的响应体。</li></ol><p>以下是执行以上步骤的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.restassured.RestAssured;<br><span class="hljs-keyword">import</span> io.restassured.http.Method;<br><span class="hljs-keyword">import</span> io.restassured.response.Response;<br><span class="hljs-keyword">import</span> io.restassured.specification.RequestSpecification;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RestAssuredAPITest</span> &#123;<br><br> <span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">GetBooksDetails</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-comment">// Specify the base URL to the RESTful web service </span><br>    RestAssured.baseURI = <span class="hljs-string">&quot;https://demoqa.com/BookStore/v1/Books&quot;</span>; <br>    <span class="hljs-comment">// Get the RequestSpecification of the request to be sent to the server. </span><br>    <span class="hljs-type">RequestSpecification</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> RestAssured.given(); <br>    <span class="hljs-comment">// specify the method type (GET) and the parameters if any. </span><br>    <span class="hljs-comment">//In this case the request does not take any parameters </span><br>    <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpRequest.request(Method.GET, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-comment">// Print the status and message body of the response received from the server </span><br>    System.out.println(<span class="hljs-string">&quot;Status received =&gt; &quot;</span> + response.getStatusLine()); <br>    System.out.println(<span class="hljs-string">&quot;Response=&gt;&quot;</span> + response.prettyPrint());<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，我们就能够发起测试 API 调用，并从对应的接口获取响应了。</p><p>现在我们来简单说明一下对应的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指定 RESTful Web 服务的基本 URL</span><br>RestAssured.baseURI = <span class="hljs-string">&quot;https://demoqa.com/BookStore/v1/Books&quot;</span>;<br></code></pre></td></tr></table></figure><p>上述代码使用 RestAssured 类来设定基本 URI。在这里，基本 URI 是 “<a href="https://demoqa.com/BookStore/v1/Books%E2%80%9D%E3%80%82%E5%9F%BA%E6%9C%AC">https://demoqa.com/BookStore/v1/Books”。基本</a> URI 指示了我们即将从服务器请求的资源的根地址（因此称为基本 URI）。然后，当我们在随后的代码中实际发起请求时，我们会添加参数（如果有的话）。</p><p>io.restassured.RestAssured 类是我们进行测试时所发起的任何类型的 HTTP 请求的基础。该类的一些关键特性包括：</p><ul><li>使用基本 URI 生成 HTTP 请求。</li><li>提供支持以创建不同的 HTTP 方法类型（GET、POST、PUT、PATCH、DELETE、UPDATE、HEAD 和 OPTIONS）的请求。</li><li>使用 HTTP 与服务器进行通信，并将测试中创建的请求发送到服务器。</li><li>接收来自服务器的响应。</li><li>提供支持验证从服务器接收到的响应。</li><li>io.restassured.RestAssured类内部使用了一个基于 Groovy 语言的 HTTP 客户端 HTTP builder 库。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取要发送到服务器的请求的RequestSpecification</span><br><span class="hljs-type">RequestSpecification</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> RestAssured.given(); <br><span class="hljs-comment">// 指定方法类型(GET)和参数(如果有的话)。</span><br><span class="hljs-comment">// 在这种情况下，请求不带任何参数。</span><br><span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpRequest.request(Method.GET, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><p>接下来的代码获取了要发送到服务器的请求的RequestSpecification对象。Rest Assured库提供了名为RequestSpecification的接口，用于此目的。变量httpRequest存储了请求，以便我们可以在需要时修改它，比如添加身份验证信息、添加头部等。在这个示例测试中，我们没有对该变量进行修改。</p><p>现在，我们调用接口以获取资源，以上代码使用request方法向服务器发送资源请求。</p><p>request方法接受两个参数，第一个是HTTP方法，第二个是一个字符串。字符串参数用于指定要与基本URI一起发送的参数。在这种情况下，为了获取Books的详情，我们不发送任何参数，因此使用了空字符串。request方法的返回类型是Response对象，这意味着request方法从服务器获取了响应并且把结果存在response这个实例中。</p><p>Response接口（io.restassured.response.Response）表示从服务器返回的响应。它包含服务器发送的所有数据。接下来的例子中可以调用此响应对象上的不同方法来提取响应，例如响应状态、header等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 打印从服务器接收到的响应消息正文</span><br>System.out.println(<span class="hljs-string">&quot;Status received =&gt; &quot;</span> + response.getStatusLine());<br>System.out.println(<span class="hljs-string">&quot;Response=&gt;&quot;</span> + response.prettyPrint());<br></code></pre></td></tr></table></figure><p>在上述代码行中，我们将响应作为字符串读取，并将其打印到System.out。我们使用响应接口的getBody方法返回响应的body。然后将其打印到System.out。</p><p>我们也可以使用Rest Assured提供的简写方法来编写上述测试代码。以下是稍微简化了的代码段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">GetWeatherDetailsCondensed</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 指定RESTful web服务的基本URL</span><br>RestAssured.baseURI = <span class="hljs-string">&quot;https://demoqa.com/BookStore/v1/Books&quot;</span>;<br><span class="hljs-comment">// 获取要发送的请求的RequestSpecification</span><br><span class="hljs-type">RequestSpecification</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> RestAssured.given();<br><span class="hljs-comment">// 调用RequestSpecification.get()方法以获取响应。</span><br><span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpRequest.get(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// Response.asString方法将直接返回主体的内容 // 作为字符串</span><br>System.out.println(<span class="hljs-string">&quot;Response Body is =&gt; &quot;</span> + response.asString());<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里使用了RequestSpecification对象上的“get”方法，该方法向接口发送了一个GET方法，返回Response对象。</p><h4 id="使用Rest-Assured验证HTTP响应状态"><a href="#使用Rest-Assured验证HTTP响应状态" class="headerlink" title="使用Rest Assured验证HTTP响应状态"></a>使用Rest Assured验证HTTP响应状态</h4><p>每个客户端发送到服务器的HTTP请求都会收到一个HTTP响应，其中包含一个状态码。这个状态码告诉我们HTTP响应是否成功。其中我们进行了一个示例的REST API测试调用。接下来将讨论如何使用REST Assured来验证HTTP响应的状态。</p><p>一个HTTP响应对象通常代表了Web服务服务器发回的HTTP数据包（响应数据包），作为对客户端请求的响应。一个HTTP响应包含状态、header、body这几个部分。当我们说需要验证HTTP响应状态时，我们希望有一种机制来读取和验证整个响应对象，包括状态、header、body，需要验证HTTP响应的每个组成部分。</p><p>同一个REST API会以XML或JSON格式返回响应消息，格式取决于HTTP请求中的Media-Type属性。那么客户端如何知道它将从API获得什么类型的响应呢？这是由响应头来管理的。响应头包含一个Content-Type属性，用于通知响应主体格式的类型。</p><p>假设我们通过浏览器向图书商店发送GET请求，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -X GET <span class="hljs-string">&quot;https://demoqa.com/BookStore/v1/Books&quot;</span> -H <span class="hljs-string">&quot;accept: application/json&quot;</span><br></code></pre></td></tr></table></figure><p>执行上述命令，结果如下：</p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rest%20Assured%E8%BF%9B%E8%A1%8CRESTful%20API%E6%B5%8B%E8%AF%95/2024-02-26-16-33-28-image.png"></p><p>如图，响应头中包含一个content-type属性，还有一些其他的属性值。通过解析这个头部，客户端就知道可以期待什么类型的响应（body）。</p><p>当客户端从服务器请求特定信息时，服务器会向客户端发送一个带有状态码的响应。服务器返回的状态码告诉我们请求是否成功。如果请求成功，服务器会在200-299的范围内发送状态码。如果请求未成功，则返回不在该范围内的状态码。</p><p>Rest Assured库提供了一个名为”io.restassured.response”的包，其中包含一个Response接口。Response接口提供了一些方法，可以帮助获取接收到的响应的各个部分。</p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rest%20Assured%E8%BF%9B%E8%A1%8CRESTful%20API%E6%B5%8B%E8%AF%95/2024-02-26-16-44-56-image.png"></p><p>其中方法 getStatusCode() 用于获取响应的状态码。该方法返回一个int，然后我们可以验证其值，这里使用TestNG Assert 用于验证状态码，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.*;<br><span class="hljs-keyword">import</span> org.testng.Assert;   <span class="hljs-comment">//用于验证响应状态 </span><br><span class="hljs-keyword">import</span> org.testng.annotations.Test;<br><span class="hljs-keyword">import</span> io.restassured.RestAssured;<br><span class="hljs-keyword">import</span> io.restassured.response.Response;<br><span class="hljs-keyword">import</span> io.restassured.specification.RequestSpecification;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RestAssuredTestResponse</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">GetBookDetails</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 指定 RESTful web 服务的基本 URL</span><br>        RestAssured.baseURI = <span class="hljs-string">&quot;https://demoqa.com/BookStore/v1/Books&quot;</span>;<br>        <span class="hljs-comment">// 获取要发送到服务器的请求的 RequestSpecification</span><br>        <span class="hljs-type">RequestSpecification</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> RestAssured.given();<br><br>        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpRequest.get(<span class="hljs-string">&quot;&quot;</span>);<br><br>        <span class="hljs-comment">// 获取请求的状态码。 </span><br>        <span class="hljs-comment">// 如果请求成功，状态码将是 200</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> response.getStatusCode();<br><br>        <span class="hljs-comment">// 断言返回正确的状态码。</span><br>        Assert.assertEquals(statusCode <span class="hljs-comment">/*实际值*/</span>, <span class="hljs-number">200</span> <span class="hljs-comment">/*期望值*/</span>, <span class="hljs-string">&quot;返回了正确的状态码&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面的代码用于获取状态码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> response.getStatusCode();<br></code></pre></td></tr></table></figure><p>返回值 “statusCode” 被与期望值即 200 进行比较。如果两个值相等，则返回相应的消息或者打印正确的log。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 断言正确的状态码已返回。</span><br>Assert.assertEquals(statusCode <span class="hljs-comment">/*实际值*/</span>, <span class="hljs-number">200</span> <span class="hljs-comment">/*期望值*/</span>, <span class="hljs-string">&quot;返回了正确的状态码&quot;</span>);<br></code></pre></td></tr></table></figure><p>通过这种方式，我们可以使用响应接口的 “getStatusCode()” 方法来验证响应的状态码，这是一种比较常见的场景，即接口返回成功的状态码2xx。接下来让我们讨论如何验证返回值不是 200（即错误状态码）的状态码，这也是另一种对接口的常见测试场景。</p><p>在实际的测试场景中可能存在诸如服务器宕机、REST API 不正常运行或请求本身存在问题等原因。总之，我们可能会遇到以下几种情况：</p><ol><li>服务器宕机。</li><li>客户端请求不正确。</li><li>客户端请求的资源不存在。</li><li>在处理请求时服务器端发生错误。</li></ol><p>当出现以上任何情况时，REST API 将返回一个错误状态码，客户端必须根据此状态码进行相应的处理。对之前给出的Demo链接，创建另一个测试，来模拟一个错误的场景。在这里，我们将验证当输入无效参数时， Web 服务返回的 HTTP 状态码。</p><p>我们提供参数以获取用户详细信息。这里我们提供了不存在的 userId 作为参数。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.*;<br><span class="hljs-keyword">import</span> org.testng.Assert;   <span class="hljs-comment">//用于验证响应状态 </span><br><span class="hljs-keyword">import</span> org.testng.annotations.Test;<br><span class="hljs-keyword">import</span> io.restassured.RestAssured;<br><span class="hljs-keyword">import</span> io.restassured.response.Response;<br><span class="hljs-keyword">import</span> io.restassured.specification.RequestSpecification;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RestAssuredTestResponse</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">GetPetDetails</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 指定 RESTful web 服务的基本 URL</span><br>        RestAssured.baseURI = <span class="hljs-string">&quot;https://demoqa.com/Account/v1/User/&quot;</span>;<br>        <span class="hljs-comment">// 获取要发送到服务器的请求的 RequestSpecification</span><br>        <span class="hljs-type">RequestSpecification</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> RestAssured.given();<br><br>        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpRequest.get(<span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-comment">// 获取请求的状态码。</span><br>        <span class="hljs-comment">// 如果请求失败，服务端返回的状态码将是401</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> response.getStatusCode();<br><br>        <span class="hljs-comment">// 断言正确的状态码已返回。</span><br>        Assert.assertEquals(statusCode <span class="hljs-comment">/*实际值*/</span>, <span class="hljs-number">401</span> <span class="hljs-comment">/*期望值*/</span>, <br>        <span class="hljs-string">&quot;返回了正确的状态码&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行这个测试，因为返回的状态码和预期的期望是相同的，所以测试通过。</p><p>除了对状态码进行验证，我们还可以验证完整的状态行及其中包含的其他消息，”状态行” 是 HTTP 响应中返回的第一行，由三个子字符串组成：</p><ol><li>HTTP 协议版本。</li><li>状态码。</li><li>状态码的字符串值。</li></ol><p>例如，当请求成功时，状态行将具有值 “HTTP&#x2F;1.1 200 OK”。这里，第一部分是 HTTP 协议（HTTP&#x2F;1.1）。接下来是 HTTP 状态码（200）。第三部分是状态消息（OK）。</p><p>我们可以使用响应接口的 <code>getStatusLine()</code> 方法来读取整个状态行。以下代码是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">GetBookDetails</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 指定 RESTful web 服务的基本 URL </span><br>    RestAssured.baseURI = <span class="hljs-string">&quot;https://demoqa.com/BookStore/v1/Books&quot;</span>; <br>    <span class="hljs-comment">// 获取要发送到服务器的请求的 RequestSpecification </span><br>    <span class="hljs-type">RequestSpecification</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> RestAssured.given(); <br>    <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpRequest.get(<span class="hljs-string">&quot;&quot;</span>); <br><br>    <span class="hljs-comment">// 将响应中的状态行读取到变量 statusLine 中</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">statusLine</span> <span class="hljs-operator">=</span> response.getStatusLine();<br>    Assert.assertEquals(statusLine <span class="hljs-comment">/*实际值*/</span>, <span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span> <br>      <span class="hljs-comment">/*期望值*/</span>, <span class="hljs-string">&quot;返回了正确的状态码&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，我们执行了类似于对状态码的测试。我们使用 <code>getStatusLine()</code> 方法读取状态行，并将其存储在字符串值中。然后，我们将此返回值与 “HTTP&#x2F;1.1 200 OK” 进行比较，以检查状态是否成功。</p><p>对于header的检验大致和对于状态码的检验相同，不过header的检验更多用的是字符串相关的校验方法，此处不做详细说明。</p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rest%20Assured%E8%BF%9B%E8%A1%8CRESTful%20API%E6%B5%8B%E8%AF%95/2024-02-26-17-12-44-image.png"></p><p>对于body的检验比较复杂，后续根据实际场景再填充内容。</p><p>&#x2F;&#x2F;TODO</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>API Testing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速上手Fiddler</title>
    <link href="/shinyruotechtips/2024/02/ecdedc2a9725/"/>
    <url>/shinyruotechtips/2024/02/ecdedc2a9725/</url>
    
    <content type="html"><![CDATA[<h4 id="Fiddler的安装"><a href="#Fiddler的安装" class="headerlink" title="Fiddler的安装"></a>Fiddler的安装</h4><p>直接从<a href="https://www.telerik.com/fiddler">Fiddler | Web Debugging Proxy and Troubleshooting Solutions (telerik.com)</a>官方下载安装Fiddler，选择适合自己操作系统的版本即可。</p><p>这篇文档使用的是Windows上的Fiddler Classic版本。</p><h4 id="快速上手抓包"><a href="#快速上手抓包" class="headerlink" title="快速上手抓包"></a>快速上手抓包</h4><p>Fiddler的使用非常的简单，对于市面上的绝大部分浏览器，只需要打开 <strong>File &gt; Capture Traffic</strong>就可以，<img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-11-05-56-image.png">也可以使用快捷键F12，或者点击左下角的<img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-11-07-32-image.png">来切换是否抓取目前浏览器上的数据。对于Firefox则需要一些额外的配置，Fiddler支持使用 <a href="https://docs.telerik.com/fiddler/KnowledgeBase/FiddlerHook">FiddlerHook</a>来抓取数据，或者也可以通过设置浏览器的SystemProxy来抓取数据。</p><p>在开始抓包之前，为了保证所有的请求都被发送和被抓取到，应该清除本地的浏览器缓存，尤其是”Cached images and files”或者cookies，浏览器缓存通常可以帮助网站更快地加载，但有时它可能阻止你看到网页的最新版本，同时也会导致某些请求不被发送。在某些情况下，旧的或损坏的缓存甚至可能导致网页加载不正确或完全无法加载。</p><p>Fiddler默认不会捕获和解密安全的HTTPS流量。若要捕获通过HTTPS协议发送的数据，需要设置启用HTTPS流量解密。</p><h6 id="启用HTTPS流量解密"><a href="#启用HTTPS流量解密" class="headerlink" title="启用HTTPS流量解密"></a>启用HTTPS流量解密</h6><ol><li><p>点击<strong>Tools &gt; Options &gt; HTTPS</strong>.</p></li><li><p>勾选<strong>Decrypt HTTPS Traffic</strong></p></li></ol><p><img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-11-27-43-image.png"></p><p>这里还有一些其他的配置，比如抓取的网络请求类型，是否忽略服务器证书错误，不解密指定主机的流量。、</p><p>Decrypt HTTPS traffic中的选项说明：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">from all processes : <br>抓取所有的 https 程序, 包括电脑程序和手机APP。<br>from browsers only : <br>只抓取浏览器中的https请求。<br>from non-browsers only : <br>只抓取除了浏览器之外的所有https请求。<br>from remote clients only：<br>只抓取远程的客户端的https请求，就是只抓取手机APP上的https请求。<br></code></pre></td></tr></table></figure><p>然后，我们需要生成证书用于加密和解密，这样Fiddler才能够解析HTTPS请求里的内容。<img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-11-43-32-image.png"></p><p>在Actions里选择<strong>Trust Root Certificate</strong>，接下来Fiddler会自动把证书添加到系统信任证书里。或者也可以选择导出证书到桌面，然后导入到需要进行抓包的浏览器中。以Edge浏览器为例，首先<strong>Export Root Certificate to Desktop</strong>，然后<strong>Settings &gt; Privacy &gt; Security &gt; Manage certificates</strong>在弹出的证书管理窗口中选择<strong>Trusted Root Certifications Authorities</strong>标签页，导入刚刚导出到桌面的证书即可。</p><p>接下来Fiddler应该就可以正常抓取HTTPS流量并且正常解析了。</p><h6 id="使用界面"><a href="#使用界面" class="headerlink" title="使用界面"></a>使用界面</h6><p><img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-13-35-52-image.png"></p><p>界面左侧为Web Sessions List，在这里我们可以看到每个请求的ID号、HTTP状态码、协议、主机名、请求资源位置、请求大小、缓存过期时间或缓存值、请求响应的类型、发送请求的进程ID、自定义注释以及Web会话的任何自定义列。</p><p><img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-14-12-15-image.png"></p><p>点击任意Web Session，右侧是详情和数据统计面板。</p><ul><li>Statistics是关于HTTP请求的性能（例如发送&#x2F;接受字节数，发送&#x2F;接收时间，还有粗略统计世界各地访问该服务器所花费的时间）以及数据分析</li></ul><p><img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-13-36-34-image.png"></p><ul><li>Inspectors用于查看会话的内容，上半部分是请求的内容，下半部分是响应的内容，提供headers、textview、hexview,Raw等多种方式查看单条http请求的请求报文的信息</li></ul><p><img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-13-39-58-image.png"></p><ul><li>AutoResponder可用于拦截某一请求，即按自己添加的指定规则重定向到本地的资源或Fiddler资源，从而代替服务器响应。比如我们在这里添加一条rule，当打开<a href="https://cn.bing.com/?mkt=zh-CN%E9%93%BE%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%94%E5%9B%9Ehttp://www.example.com%E8%BF%99%E4%B8%AA%E7%BB%93%E6%9E%9C!%5B%5D(../imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-13-45-48-image.png)">https://cn.bing.com/?mkt=zh-CN链接的时候返回http://www.example.com这个结果![](../imgs/快速上手Fiddler/2024-02-05-13-45-48-image.png)</a></li></ul><p>这时候我们去访问rule里这个链接，就会返回被劫持之后的结果。<img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-13-47-29-image.png"></p><ul><li><p>Composer自定义请求发送服务器，Parsed模式下你只需要提供简单的URLS地址即可，也可以直接把左侧Sessions List里的session拖动到这里从而构成请求，点击Execute</p><p><img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-13-53-25-image.png"></p></li></ul><p>在左侧就可以看到这个请求<img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-13-54-01-image.png"></p><p><img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-13-54-27-image.png"></p><ul><li><p>Fiddler Orchestra</p><p>这是一个用于监听抓取APP的插件，原理是让APP连接到Orchestra服务后，Orchestra在正常转发流量的同时再复制一份流量给Fiddler，就可以让Fiddler抓取到相应的流量。</p></li><li><p>Fiddler Script 包含了一个脚本文件可以自动修改Http Request 和Response.这样我们就不需要手动地下”断点”去修改了，该脚本中提供了许多Hook以及在指定的事件节点对网络上的请求进行修改的方法。修改细则可以看<a href="https://www.telerik.com/blogs/understanding-fiddlerscript">Understanding FiddlerScript (telerik.com)</a></p></li><li><p>Log 运行的log。</p></li><li><p>Filters 过滤规则，通过设置过滤规则来过滤所需的http请求，最常用的过滤条件：Zone和Host。</p></li></ul><p><img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-14-05-33-image.png"></p><p><img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-14-05-41-image.png"></p><ul><li>Timeline 请求响应时间，在左侧会话窗口点击一个或多个请求，Timeline 便会可视化指定内容从服务端传输到客户端的时间。</li></ul><h4 id="断点功能"><a href="#断点功能" class="headerlink" title="断点功能"></a>断点功能</h4><p><img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-14-08-22-image.png">在这里通过点击可以设置断点，支持截获全部请求、截获全部请求响应。也可以使用QuickExec命令设置断点，更灵活一些。</p><p><img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-14-14-32-image.png"></p><p>通过断点我们可以在Sessions List中选择被中断的会话，然后对其中的内容进行修改，比如Forms等。</p><h4 id="Fiddler-HTTPS-抓包原理"><a href="#Fiddler-HTTPS-抓包原理" class="headerlink" title="Fiddler HTTPS 抓包原理"></a>Fiddler HTTPS 抓包原理</h4><p><img src="/shinyruotechtips/imgs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFiddler/2024-02-05-14-00-55-image.png"></p><p>Fiddler 是浏览器的服务器，而 Fiddler 是服务器的客户端。在没有 Fiddler 的情况下，浏览器拥有的公开证书来自服务器，服务器保存私有证书。服务器使用私有证书对数据进行加密，浏览器使用公有证书对数据解密。</p><p>我们在中间添加了一个 Fiddler 作为代理，那么此时客户端拥有的公共证书应该来自 Fiddler，而 Fiddler 拥有私有证书的同时，还拥有来自服务器的公共证书。浏览器和服务器交互如下：</p><ul><li><p><strong>请求</strong>：浏览器使用 Fiddler 公共证书将数据加密，发送给 Fiddler。Fiddler 使用私有证书解密，然后将内容采用服务器的公共证书再次加密，发送给服务器，服务器使用自己的私有证书进行解密。</p></li><li><p><strong>响应</strong>：服务器使用私有证书对响应数据加密，然后发送给 Fiddler。Fiddler 将收到的数据使用服务器的公共证书解密，然后再次使用自己的私有证书加密，将再次加密后的数据发送为浏览器，浏览器收到后使用 Fiddler 的公共证书进行解密，将解密的内容最终展现给用户。</p></li></ul><h4 id="与Wireshark的比较"><a href="#与Wireshark的比较" class="headerlink" title="与Wireshark的比较"></a>与Wireshark的比较</h4><p>Wireshark对底层协议的支持更好，一到七层都能抓，对于协议细节内容的Debug更有帮助，每个数据包就是一个完整的帧，同时可以结合tcpdump工具去分析服务器之间的通讯。但是wireshark解密HTTPS数据包比较麻烦。</p><p>Fiddler主要使用场景还是偏向业务层面，对于移动端的配置也比较方便，一般是用于接口测试。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Fiddler</tag>
      
      <tag>Tools</tag>
      
      <tag>RTFM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10分钟搭建pytest框架</title>
    <link href="/shinyruotechtips/2024/01/dca0c4d7d5ba/"/>
    <url>/shinyruotechtips/2024/01/dca0c4d7d5ba/</url>
    
    <content type="html"><![CDATA[<p>在搭建一个pytest Demo之前，首先安装pytest，pytest对于Python版本的要求是3.8+</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt; pip install -U pytest<br>&gt;&gt; pytest --version<br>pytest 7.4.4<br></code></pre></td></tr></table></figure><h4 id="创建第一个测试"><a href="#创建第一个测试" class="headerlink" title="创建第一个测试"></a>创建第一个测试</h4><p>创建一个包含一个函数和一个测试的<code>test_sample.py</code>文件，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_sample.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_answer</span>():<br>    <span class="hljs-keyword">assert</span> func(<span class="hljs-number">3</span>) == <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt; pytest<br>=============================================== <span class="hljs-built_in">test</span> session starts ================================================<br>platform win32 -- Python 3.12.1, pytest-7.4.4, pluggy-1.4.0<br>rootdir: C:\Users\miaoh\Desktop\pytest<br>collected 1 item                                                                                                     <br><br>test_sample.py F                                                                                              [100%]<br><br>===================================================== FAILURES ===================================================== <br>___________________________________________________ test_answer ____________________________________________________ <br><br>    def test_answer():<br>&gt;       assert func(3) == 5<br>E       assert 4 == 5<br>E        +  <span class="hljs-built_in">where</span> 4 = func(3)<br><br>test_sample.py:7: AssertionError<br>============================================= short <span class="hljs-built_in">test</span> summary info ============================================== <br>FAILED test_sample.py::test_answer - assert 4 == 5<br>================================================ 1 failed <span class="hljs-keyword">in</span> 0.06s ================================================= <br></code></pre></td></tr></table></figure><p>这里的<code>[100%]</code>指的是运行的所有测试用例的进度。很明显，fun(3)返回的结果是4，这个assert失败了。</p><h4 id="运行多个测试用例"><a href="#运行多个测试用例" class="headerlink" title="运行多个测试用例"></a>运行多个测试用例</h4><p>简言之，<code>pytest</code> 会在运行该命令的当前目录和子目录中查找格式为test_*.py or *_test.py的文件并且运行，具体的查找规则参考<a href="https://docs.pytest.org/en/latest/explanation/goodpractices.html#test-discovery">standard test discovery rules</a></p><h4 id="断言一个特定的异常"><a href="#断言一个特定的异常" class="headerlink" title="断言一个特定的异常"></a>断言一个特定的异常</h4><p>参考<a href="https://docs.pytest.org/en/latest/how-to/assert.html#assertraises">raises</a>我们可以断言某个异常的发生</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_sysexit.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>():<br>    <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_mytest</span>():<br>    <span class="hljs-keyword">with</span> pytest.raises(SystemExit):<br>        f()<br></code></pre></td></tr></table></figure><p>也可以使用由raises](<a href="https://docs.pytest.org/en/latest/how-to/assert.html#assertraises">How to write and report assertions in tests &amp;#8212; pytest documentation</a>)提供的上下文来断言预期的异常是抛出的<a href="https://docs.python.org/3/library/exceptions.html#ExceptionGroup" title="(in Python v3.12)"><code>ExceptionGroup</code></a>的一部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_exceptiongroup.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>():<br>    <span class="hljs-keyword">raise</span> ExceptionGroup(<br>        <span class="hljs-string">&quot;Group message&quot;</span>,<br>        [<br>            RuntimeError(),<br>        ],<br>    )<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_exception_in_group</span>():<br>    <span class="hljs-keyword">with</span> pytest.raises(ExceptionGroup) <span class="hljs-keyword">as</span> excinfo:<br>        f()<br>        <span class="hljs-keyword">assert</span> excinfo.group_contains(RuntimeError)<br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> excinfo.group_contains(TypeError)<br></code></pre></td></tr></table></figure><p>这个case会失败，因为在目前的stable版本python中，这个Execinfo方法还什么都没有写，而<code>assert</code>需要后边是个boolean值。在GitHub pytest的issue里也可以看到有相关的issue</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">group_contains</span>(<span class="hljs-params">self, RuntimeError</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h4 id="在一个类中定义多个测试用例"><a href="#在一个类中定义多个测试用例" class="headerlink" title="在一个类中定义多个测试用例"></a>在一个类中定义多个测试用例</h4><p>当你添加多个测试用例的时候，你可能希望将它们分组到一个类中。pytest使得创建包含多个测试的类变得很容易：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_class.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_one</span>(<span class="hljs-params">self</span>):<br>        x = <span class="hljs-string">&quot;this&quot;</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;h&quot;</span> <span class="hljs-keyword">in</span> x<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_two</span>(<span class="hljs-params">self</span>):<br>        x = <span class="hljs-string">&quot;hello&quot;</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">hasattr</span>(x, <span class="hljs-string">&quot;check&quot;</span>)<br></code></pre></td></tr></table></figure><p>pytest会根据我们之前提到的python测试发现的规定来发现所有的测试，所以它会找到所有以test_为前缀的函数。不需要通过继承任何类来实现，但是确保你的类的前缀是<code>Test</code>，否则这个类会被跳过。我们可以通过传递文件名来运行模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pytest -q test_class.py</span><br>.F                                                                   [100%]<br>================================= FAILURES =================================<br>____________________________ TestClass.test_two ____________________________<br><br>self = &lt;test_class.TestClass object at 0xdeadbeef0001&gt;<br><br>    def test_two(self):<br>        x = &quot;hello&quot;<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">      assert hasattr(x, <span class="hljs-string">&quot;check&quot;</span>)</span><br>E       AssertionError: assert False<br>E        +  where False = hasattr(&#x27;hello&#x27;, &#x27;check&#x27;)<br><br>test_class.py:8: AssertionError<br>========================= short test summary info ==========================<br>FAILED test_class.py::TestClass::test_two - AssertionError: assert False<br>1 failed, 1 passed in 0.12s<br></code></pre></td></tr></table></figure><p>第一个测试通过了，第二个测试失败了。你可以很容易地看到断言中的中间值，帮助你理解失败的原因。</p><p>将测试分组到类中可能有以下好处：</p><ul><li>方便组织测试用例</li><li>仅在该特定类中共享fixtures</li><li>在类级别应用标记，并隐式地应用到所有测试</li></ul><p>当在类中分组测试时，需要注意的是每个测试用例都对分别对该类进行实例化，所以类的值不能在测试用例之间共享。让每个测试共享同一个类实例对测试隔离非常不利。这在下面有详细说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_class_demo.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClassDemoInstance</span>:<br>    value = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_one</span>(<span class="hljs-params">self</span>):<br>        self.value = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">assert</span> self.value == <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_two</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">assert</span> self.value == <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pytest -k TestClassDemoInstance -q</span><br>.F                                                                   [100%]<br>================================= FAILURES =================================<br>______________________ TestClassDemoInstance.test_two ______________________<br><br>self = &lt;test_class_demo.TestClassDemoInstance object at 0xdeadbeef0002&gt;<br><br>    def test_two(self):<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">      assert self.value == 1</span><br>E       assert 0 == 1<br>E        +  where 0 = &lt;test_class_demo.TestClassDemoInstance object at 0xdeadbeef0002&gt;.value<br><br>test_class_demo.py:9: AssertionError<br>========================= short test summary info ==========================<br>FAILED test_class_demo.py::TestClassDemoInstance::test_two - assert 0 == 1<br>1 failed, 1 passed in 0.12s<br></code></pre></td></tr></table></figure><p>请注意，添加&#x2F;更改类级别的属性是类属性，它们会在测试用例之间共享。有关类属性和实例属性以及命名空间的概念属于python的语法知识，此处不做解释。</p><h4 id="为功能测试请求一个特殊的临时目录"><a href="#为功能测试请求一个特殊的临时目录" class="headerlink" title="为功能测试请求一个特殊的临时目录"></a>为功能测试请求一个特殊的临时目录</h4><p><code>pytest</code>提供了内置的fixtures&#x2F;函数参数来请求任意资源，比如一个唯一的临时目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_tmp_path.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_needsfiles</span>(<span class="hljs-params">tmp_path</span>):<br>    <span class="hljs-built_in">print</span>(tmp_path)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>在测试函数签名中列出 <code>tmp_path</code> 名称，<code>pytest</code>将查找并调用一个<code>fixture factory</code>来在执行测试函数调用之前创建资源。在测试运行之前，<code>pytest</code>会创建一个每次测试调用都唯一的临时目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pytest -q test_tmp_path.py</span><br>F                                                                    [100%]<br>================================= FAILURES =================================<br>_____________________________ test_needsfiles ______________________________<br><br>tmp_path = PosixPath(&#x27;PYTEST_TMPDIR/test_needsfiles0&#x27;)<br><br>    def test_needsfiles(tmp_path):<br>        print(tmp_path)<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">      assert 0</span><br>E       assert 0<br><br>test_tmp_path.py:3: AssertionError<br>--------------------------- Captured stdout call ---------------------------<br>PYTEST_TMPDIR/test_needsfiles0<br>========================= short test summary info ==========================<br>FAILED test_tmp_path.py::test_needsfiles - assert 0<br>1 failed in 0.12s<br></code></pre></td></tr></table></figure><p>关于临时目录的相信文档可以在 <a href="https://docs.pytest.org/en/stable/how-to/tmp_path.html#tmp-path-handling">Temporary directories and files</a>找到。</p><p>你可以使用以下命令查看哪些内置的<code>pytest fixtures</code>存在，并且有一个简单的pydoc说明这个fixture是做什么的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pytest --fixtures   # 显示内置和自定义的fixtures<br></code></pre></td></tr></table></figure><p>注意，除非添加了 <code>-v</code> 选项，否则这个命令会省略以 <code>_</code> 开头的fixtures。</p><p><a href="https://github.com/DouyuShinyruo/pytest">Demo Repo</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Framework</tag>
      
      <tag>pytest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10分钟搭建Cucumber框架</title>
    <link href="/shinyruotechtips/2024/01/a9e472a14e25/"/>
    <url>/shinyruotechtips/2024/01/a9e472a14e25/</url>
    
    <content type="html"><![CDATA[<h4 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h4><p>在我们开始之前，需要以下内容：</p><ul><li>Java SE</li><li>构建工具。此处选择：<ul><li>Maven - 版本3.3.1或更高</li><li>IntelliJ IDEA</li><li>IntelliJ IDEA Cucumber for Java 插件</li></ul></li></ul><p>首先使用cucumber-archetype Maven插件创建一个空的Cucumber项目，在要创建项目的目录下打开本地Terminal，并运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mvn archetype:generate <span class="hljs-string">&quot;-DarchetypeGroupId=io.cucumber&quot;</span> <span class="hljs-string">&quot;-DarchetypeArtifactId=cucumber-archetype&quot;</span> <span class="hljs-string">&quot;-DarchetypeVersion=7.15.0&quot;</span> <span class="hljs-string">&quot;-DgroupId=com.shinyruo&quot;</span>  <span class="hljs-string">&quot;-DartifactId=hellocucumber&quot;</span> <span class="hljs-string">&quot;-Dpackage=hellocucumber&quot;</span> <span class="hljs-string">&quot;-Dversion=1.0.0-SNAPSHOT&quot;</span>    <span class="hljs-string">&quot;-DinteractiveMode=false&quot;</span>如果你本地没有这个插件的话，这个命令需要运行一会儿，<br></code></pre></td></tr></table></figure><p>如果本地没有这个插件，Maven会自动下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[INFO] Project created from Archetype <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>: &lt;directory <span class="hljs-built_in">where</span> you created the project&gt;/cucumber<br>[INFO] ------------------------------------------------------------------------<br>[INFO] BUILD SUCCESS<br>[INFO] ------------------------------------------------------------------------<br></code></pre></td></tr></table></figure><p>在IntelliJ IDEA中打开项目，运行Cucumber试试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mvn <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>应该会看到类似以下的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.141 s -- <span class="hljs-keyword">in</span> hellocucumber.RunCucumberTest<br>[INFO] <br>[INFO] Results:<br>[INFO]<br>[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0<br>[INFO]<br>[INFO] ------------------------------------------------------------------------<br>[INFO] BUILD SUCCESS<br>[INFO] ------------------------------------------------------------------------<br></code></pre></td></tr></table></figure><p>Cucumber此处运行了example.feature这个文件中给出的示例场景（Scenario）。</p><h4 id="写一个场景（Scenario）"><a href="#写一个场景（Scenario）" class="headerlink" title="写一个场景（Scenario）"></a>写一个场景（Scenario）</h4><p>在Cucumber中进行行为驱动开发时，我们使用具体的示例来指定软件应该做什么。场景在生成代码之前编写。它们开始作为可执行规范。随着生成代码的出现，场景将扮演实时文档和自动化测试的角色。</p><p>在Cucumber中，一个示例被称为场景（Scenario）。场景定义在.feature文件中，这些文件默认存储在src&#x2F;test&#x2F;resources&#x2F;hellocucumber目录（或子目录）中，当然，根据项目的需要，我们可以更改这个配置，在指定的目录下存储对应的.feature文件。比如在这个项目中，我们给RunCucumberTest加上这个注解<code>@ConfigurationParameter(key = FEATURES_PROPERTY_NAME, value = &quot;src/test/resources/features&quot;)</code>就把这个目录更改为了src&#x2F;test&#x2F;resources&#x2F;features这个目录（或子目录）。</p><p>接下来我们通过一个例子来表明应该如何写一个具体的场景。</p><p>创建一个src&#x2F;test&#x2F;resources&#x2F;features&#x2F;is_it_friday_yet.feature文件，内容如下：</p><figure class="highlight feature"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs feature"><span class="hljs-keyword">Feature</span>: Is it Friday yet?<br>  Everybody wants to know when it&#x27;s Friday<br><br>  <span class="hljs-keyword">Scenario</span>: Sunday isn&#x27;t Friday<br>    <span class="hljs-keyword">Given</span> today is Sunday<br>    <span class="hljs-keyword">When</span> I ask whether it&#x27;s Friday yet<br>    <span class="hljs-keyword">Then</span> I should be told <span class="hljs-string">&quot;Nope&quot;</span><br></code></pre></td></tr></table></figure><p>这个文件的第一行以关键字Feature:开头，后面跟着一个名称。可以使用与文件名相似的名称，或者根据业务需求对功能本身进行概括。</p><p>第二行是功能的简要描述。Cucumber不执行此行，因为它是文档&#x2F;注释的一部分。</p><p>第四行，Scenario: Sunday isn’t Friday是一个场景，它是一个具体的示例，说明在这里软件所处的状态，或者业务场景。</p><p>以Given，When和Then开头的最后三行是我们场景的步骤。这是Cucumber将执行的内容。</p><h4 id="查看报告中的未定义场景"><a href="#查看报告中的未定义场景" class="headerlink" title="查看报告中的未定义场景"></a>查看报告中的未定义场景</h4><p>现在我们有了一个场景，我们可以要求Cucumber执行它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mvn <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>Cucumber告诉我们有一个未定义的场景和三个未定义的步骤。它还建议一些代码片段，我们可以用这些代码片段来定义这些步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs bash">Scenario: Sunday isn<span class="hljs-string">&#x27;t Friday        # src/test/resources/features/is_it_friday_yet.feature:4</span><br><span class="hljs-string">  Given today is Sunday</span><br><span class="hljs-string">  When I ask whether it&#x27;</span>s Friday yet<br>  Then I should be told <span class="hljs-string">&quot;Nope&quot;</span><br>[ERROR] Tests run: 2, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.142 s &lt;&lt;&lt; <span class="hljs-string">FAILURE! -- in hellocucumber.RunCucumberTest</span><br><span class="hljs-string">[ERROR] Is it Friday yet?.Sunday isn&#x27;t Friday -- Time elapsed: 0.024 s &lt;&lt;&lt; ERROR!</span><br><span class="hljs-string">io.cucumber.junit.platform.engine.UndefinedStepException:</span><br><span class="hljs-string">The step &#x27;today is Sunday&#x27; and 2 other step(s) are undefined.</span><br><span class="hljs-string">You can implement these steps using the snippet(s) below:</span><br><span class="hljs-string"></span><br><span class="hljs-string">@Given(&quot;today is Sunday&quot;)</span><br><span class="hljs-string">public void today_is_sunday() &#123;</span><br><span class="hljs-string">    // Write code here that turns the phrase above into concrete actions</span><br><span class="hljs-string">    throw new io.cucumber.java.PendingException();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">@When(&quot;I ask whether it&#x27;s Friday yet&quot;)</span><br><span class="hljs-string">public void i_ask_whether_it_s_friday_yet() &#123;</span><br><span class="hljs-string">    // Write code here that turns the phrase above into concrete actions</span><br><span class="hljs-string">    throw new io.cucumber.java.PendingException();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">@Then(&quot;I should be told &#123;string&#125;&quot;)</span><br><span class="hljs-string">public void i_should_be_told(String string) &#123;</span><br><span class="hljs-string">    // Write code here that turns the phrase above into concrete actions</span><br><span class="hljs-string">    throw new io.cucumber.java.PendingException();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">        at io.cucumber.core.runtime.TestCaseResultObserver.assertTestCasePassed(TestCaseResultObserver.java:69)</span><br><span class="hljs-string">        at io.cucumber.junit.platform.engine.TestCaseResultObserver.assertTestCasePassed(TestCaseResultObserver.java:22)</span><br><span class="hljs-string">        at io.cucumber.junit.platform.engine.CucumberEngineExecutionContext.lambda$runTestCase$4(CucumberEngineExecutionContext.java:114)</span><br><span class="hljs-string">        at io.cucumber.core.runtime.CucumberExecutionContext.lambda$runTestCase$5(CucumberExecutionContext.java:137)</span><br><span class="hljs-string">        at io.cucumber.core.runtime.RethrowingThrowableCollector.executeAndThrow(RethrowingThrowableCollector.java:23)</span><br><span class="hljs-string">        at io.cucumber.core.runtime.CucumberExecutionContext.runTestCase(CucumberExecutionContext.java:137)</span><br><span class="hljs-string">        at io.cucumber.junit.platform.engine.CucumberEngineExecutionContext.runTestCase(CucumberEngineExecutionContext.java:109)</span><br><span class="hljs-string">        at io.cucumber.junit.platform.engine.NodeDescriptor$PickleDescriptor.execute(NodeDescriptor.java:168)</span><br><span class="hljs-string">        at io.cucumber.junit.platform.engine.NodeDescriptor$PickleDescriptor.execute(NodeDescriptor.java:90)</span><br><span class="hljs-string">        at java.util.ArrayList.forEach(ArrayList.java:1259)</span><br><span class="hljs-string">        at java.util.ArrayList.forEach(ArrayList.java:1259)</span><br><span class="hljs-string"></span><br><span class="hljs-string">[INFO] </span><br><span class="hljs-string">[INFO] Results:</span><br><span class="hljs-string">[INFO]</span><br><span class="hljs-string">[ERROR] Errors: </span><br><span class="hljs-string">[ERROR]   The step &#x27;today is Sunday&#x27; and 2 other step(s) are undefined.</span><br><span class="hljs-string">You can implement these steps using the snippet(s) below:</span><br><span class="hljs-string"></span><br><span class="hljs-string">@Given(&quot;today is Sunday&quot;)</span><br><span class="hljs-string">public void today_is_sunday() &#123;</span><br><span class="hljs-string">    // Write code here that turns the phrase above into concrete actions</span><br><span class="hljs-string">    throw new io.cucumber.java.PendingException();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">@When(&quot;I ask whether it&#x27;s Friday yet&quot;)</span><br><span class="hljs-string">public void i_ask_whether_it_s_friday_yet() &#123;</span><br><span class="hljs-string">    // Write code here that turns the phrase above into concrete actions</span><br><span class="hljs-string">    throw new io.cucumber.java.PendingException();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">@Then(&quot;I should be told &#123;string&#125;&quot;)</span><br><span class="hljs-string">public void i_should_be_told(String string) &#123;</span><br><span class="hljs-string">    // Write code here that turns the phrase above into concrete actions</span><br><span class="hljs-string">    throw new io.cucumber.java.PendingException();</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>复制每个未定义步骤的三个代码片段，并将它们粘贴到src&#x2F;test&#x2F;java&#x2F;hellocucumber&#x2F;stepdefs&#x2F;common&#x2F;Friday.java中。</p><p>再次运行Cucumber。这次输出有点不同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR] Tests run: 2, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.107 s &lt;&lt;&lt; <span class="hljs-string">FAILURE! -- in hellocucumber.RunCucumberTest</span><br><span class="hljs-string">[ERROR] Is it Friday yet?.Sunday isn&#x27;t Friday -- Time elapsed: 0.007 s &lt;&lt;&lt; ERROR!</span><br><span class="hljs-string">io.cucumber.java.PendingException: TODO: implement me</span><br><span class="hljs-string">        at hellocucumber.stepdefs.common.Friday.today_is_sunday(Friday.java:9)</span><br></code></pre></td></tr></table></figure><p>Cucumber找到了我们的步骤定义并执行了它们。它们当前标记为挂起，这意味着我们需要使它们做一些有用的事情，也就是对这些step进行实现。</p><h4 id="查看报告中的失败-x2F-通过场景"><a href="#查看报告中的失败-x2F-通过场景" class="headerlink" title="查看报告中的失败&#x2F;通过场景"></a>查看报告中的失败&#x2F;通过场景</h4><p>下一步是按步骤定义中的注释所示做一些事情：</p><p>“&#x2F;&#x2F; Write code here that turns the phrase above into concrete actions”</p><p>将步骤定义代码src&#x2F;test&#x2F;java&#x2F;com&#x2F;shinyruo&#x2F;hellocucumber&#x2F;stepdefs&#x2F;common&#x2F;Friday.java更改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shinyruo.hellocucumber.stepdefs.common;<br><br><span class="hljs-keyword">import</span> io.cucumber.java.en.*;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.jupiter.api.Assertions.assertEquals;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Friday</span> &#123;<br>    <span class="hljs-keyword">private</span> String today;<br>    <span class="hljs-keyword">private</span> String actualAnswer;<br><br>    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">isItFriday</span><span class="hljs-params">(String today)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Given(&quot;today is Sunday&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">today_is_Sunday</span><span class="hljs-params">()</span> &#123;<br>        today = <span class="hljs-string">&quot;Sunday&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@When(&quot;I ask whether it&#x27;s Friday yet&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">i_ask_whether_it_s_Friday_yet</span><span class="hljs-params">()</span> &#123;<br>        actualAnswer = isItFriday(today);<br>    &#125;<br><br>    <span class="hljs-meta">@Then(&quot;I should be told &#123;string&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">i_should_be_told</span><span class="hljs-params">(String expectedAnswer)</span> &#123;<br>        assertEquals(expectedAnswer, actualAnswer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次运行Cucumber：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR] Is it Friday yet?.Sunday isn<span class="hljs-string">&#x27;t Friday -- Time elapsed: 0.009 s &lt;&lt;&lt; FAILURE!</span><br><span class="hljs-string">org.opentest4j.AssertionFailedError: expected: &lt;Nope&gt; but was: &lt;null&gt;</span><br><span class="hljs-string">        at com.shinyruo.hellocucumber.stepdefs.common.Friday.i_should_be_told(Friday.java:26)</span><br><span class="hljs-string">        at ?.I should be told &quot;Nope&quot;</span><br></code></pre></td></tr></table></figure><p>前两个步骤通过了，但是最后一个步骤失败了。很明显，这是因为我们的方法中返回了null，我们把它改成Nope：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String <span class="hljs-title function_">isItFriday</span><span class="hljs-params">(String today)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Nope&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次运行Cucumber：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">[INFO] Running com.shinyruo.hellocucumber.RunCucumberTest<br><br>Scenario: The example                       <span class="hljs-comment"># src/test/resources/features/example.feature:3</span><br>  Given an example scenario                 <span class="hljs-comment"># com.shinyruo.hellocucumber.stepdefs.common.StepDefinitions.anExampleScenario()</span><br>  When all step definitions are implemented <span class="hljs-comment"># com.shinyruo.hellocucumber.stepdefs.common.StepDefinitions.allStepDefinitionsAreImplemented()</span><br>  Then the scenario passes                  <span class="hljs-comment"># com.shinyruo.hellocucumber.stepdefs.common.StepDefinitions.theScenarioPasses()</span><br><br>Scenario: Sunday isn<span class="hljs-string">&#x27;t Friday        # src/test/resources/features/is_it_friday_yet.feature:4</span><br><span class="hljs-string">  Given today is Sunday              # com.shinyruo.hellocucumber.stepdefs.common.Friday.today_is_Sunday()</span><br><span class="hljs-string">  When I ask whether it&#x27;</span>s Friday yet <span class="hljs-comment"># com.shinyruo.hellocucumber.stepdefs.common.Friday.i_ask_whether_it_s_Friday_yet()</span><br>  Then I should be told <span class="hljs-string">&quot;Nope&quot;</span>       <span class="hljs-comment"># com.shinyruo.hellocucumber.stepdefs.common.Friday.i_should_be_told(java.lang.String)</span><br>[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.100 s -- <span class="hljs-keyword">in</span> com.shinyruo.hellocucumber.RunCucumberTest<br>[INFO] <br>[INFO] Results:<br>[INFO]<br>[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0<br>[INFO]<br>[INFO] ------------------------------------------------------------------------<br>[INFO] BUILD SUCCESS<br>[INFO] ------------------------------------------------------------------------<br></code></pre></td></tr></table></figure><p>现在，我们的用例就都是通过状态了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总之，我们现在有了一个非常简陋的cucumber框架，更复杂的场景以及与其他测试工具的集成我们可以后边逐步实现。</p><p><a href="https://github.com/DouyuShinyruo/cucumber">Demo Repo</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Cucumber</tag>
      
      <tag>Framework</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>北美科技公司对工程技术角色的区分</title>
    <link href="/shinyruotechtips/2024/01/72ac063e860c/"/>
    <url>/shinyruotechtips/2024/01/72ac063e860c/</url>
    
    <content type="html"><![CDATA[<p>科普一下北美科技公司对工程技术角色的区分，比如 EM(Engineering Manager)、TPM (Technical Program Manager) 都代表什么意思，分工有什么不同？</p><p>通常北美的工程技术相关的职业分成以下五个类别：</p><ul><li>开发工程师 SE &#x2F; SDE(Software Engineer &#x2F; Software Development Engineer)</li><li>工程经理 EM &#x2F; SDM(Engineering Manager &#x2F; Software Development Manager)</li><li>技术主管 TL &#x2F; TLM (Tech Lead &#x2F; Tech Lead Manager)</li><li>技术项目经理 TPM (Technical Program Manager)</li><li>产品经理 PM (Product Manager)</li></ul><p>这些角色之间的差别很难描述，知名技术专栏 The Pragmatic Engineer 的作者，前 Uber 的工程经理 Gergely Orosz 写过一篇文章：《<a href="https://newsletter.pragmaticengineer.com/p/engineering-leadership-skillset-overlaps">Engineering Leadership Skill Set Overlaps</a>》，从三个维度来区分这些角色之间的差别，相对比较准确客观。</p><p><img src="/shinyruotechtips/imgs/%E5%8C%97%E7%BE%8E%E7%A7%91%E6%8A%80%E5%85%AC%E5%8F%B8%E5%AF%B9%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF%E8%A7%92%E8%89%B2%E7%9A%84%E5%8C%BA%E5%88%86/2024-01-23-16-27-27-image.png"></p><p>这三个维度分别是：</p><ul><li>战略对齐：明确组织的愿景、使命和战略；与团队工作在一起，保持战略上的一致，避免资源上的浪费；保持各团队之间信息通畅，处理好团队之间的依赖关系，让团队一起协作。</li><li>人员管理：确保团队健康，帮助团队成员成长，推动团队的执行。</li><li>软件开发：与生成产品代码直接相关的工作，比如系统设计、编码、代码审查、部署、监控等等。</li></ul><p>虽然这三个维度不足以覆盖各个工程角色中的所有活动（比如行政、招聘），但确实可以很好的用可视化的方式来区分各个工程角色的差别。</p><p>让我们具体看一下各个角色的主要工作职责：</p><h4 id="开发工程师-SE-x2F-SDE-Software-Engineer-x2F-Software-Development-Engineer"><a href="#开发工程师-SE-x2F-SDE-Software-Engineer-x2F-Software-Development-Engineer" class="headerlink" title="开发工程师 SE &#x2F; SDE(Software Engineer &#x2F; Software Development Engineer)"></a>开发工程师 SE &#x2F; SDE(Software Engineer &#x2F; Software Development Engineer)</h4><ul><li>开发工程师主要以技术开发为主</li><li>资深的工程师会参与一些跨团队的协作，以及指导新手工程师</li><li>不会涉及人员管理</li></ul><h4 id="工程经理-EM-x2F-SDM-Engineering-Manager-x2F-Software-Development-Manager"><a href="#工程经理-EM-x2F-SDM-Engineering-Manager-x2F-Software-Development-Manager" class="headerlink" title="工程经理 EM &#x2F; SDM(Engineering Manager &#x2F; Software Development Manager)"></a>工程经理 EM &#x2F; SDM(Engineering Manager &#x2F; Software Development Manager)</h4><ul><li>工程经理则以人员管理为主，要花大量时间在团队建设和帮助员工成长上面</li><li>需要将组织的战略和团队以及团队成员对齐，确保团队做的事情和部门或公司的目标是一致的</li><li>要和产品经理、技术项目经理协作，参与项目管理，设定项目目标，制定项目计划，推动项目进展</li><li>软件开发相关的工作占比极少，通常只是参与技术决策和代码审查，即使参与开发也不应负责关键模块，否则容易成为团队瓶颈</li></ul><h4 id="技术主管-TL-x2F-TLM-Tech-Lead-x2F-Tech-Lead-Manager"><a href="#技术主管-TL-x2F-TLM-Tech-Lead-x2F-Tech-Lead-Manager" class="headerlink" title="技术主管 TL &#x2F; TLM (Tech Lead &#x2F; Tech Lead Manager)"></a>技术主管 TL &#x2F; TLM (Tech Lead &#x2F; Tech Lead Manager)</h4><ul><li>技术主管会直接参与开发，和工程师相比比例要低一些，还要帮助团队做出技术决策</li><li>技术主管有少量的人员管理职责，以技术指导为主，一般不会涉及绩效、人事相关</li><li>技术主管会和产品经理协作推动项目进展，偏项目执行层面</li></ul><h4 id="技术项目经理-TPM-Technical-Program-Manager"><a href="#技术项目经理-TPM-Technical-Program-Manager" class="headerlink" title="技术项目经理 TPM (Technical Program Manager)"></a>技术项目经理 TPM (Technical Program Manager)</h4><ul><li>技术项目经理主要职责是管理推动跨多个团队的大型复杂项目</li><li>通常不涉及人员管理，除非是资深的 TPM 下面还带 TPM</li><li>要花大量时间和 stakeholders（利益相关方）沟通协作，从而推动项目进展</li></ul><h4 id="产品经理-PM-Product-Manager"><a href="#产品经理-PM-Product-Manager" class="headerlink" title="产品经理 PM (Product Manager)"></a>产品经理 PM (Product Manager)</h4><ul><li><p>产品经理需要将组织的战略转化成产品设计</p></li><li><p>产品经理需要花大量时间和 SDE、EM、TPM 一起协作，确保产品设计能被理解和执行</p></li><li><p>产品经理通常不涉及人员管理，除非是资深产品经理或产品总监，有直接下属</p></li><li><p>职责和角色的对应关系</p></li></ul><p>除了上面说的软件开发、战略对齐和人员管理三种维度，还有一种更简单直接的区分方法是按照职责来划分，将职责划分成：项目管理 (Project Management)、人员管理 (People Management) 和技术 (Technical Leadership) 三部分。</p><ul><li><strong>工程经理（EM）</strong> 以人员管理为主，但是也会兼顾一部分的技术和项目管理</li><li><strong>技术主管（TL）</strong> 以技术为主，兼顾少量项目管理和人员管理</li><li><strong>项目经理（TPM）</strong> 以项目管理为主，不怎么参与人员管理和技术</li></ul><p>以上就是通常北美的大型科技公司在技术公司工程团队中各个角色的介绍，以及区分。</p><h3 id="不同的体量的公司中各个角色分别负责什么？"><a href="#不同的体量的公司中各个角色分别负责什么？" class="headerlink" title="不同的体量的公司中各个角色分别负责什么？"></a>不同的体量的公司中各个角色分别负责什么？</h3><p>不同的公司由于团队规模不一样，所以角色划分也有所不同，上面的划分主要是针对大型科技公司的组织架构来划分的角色，对于中小公司其实没有那么细。比如创业公司老板什么都做，中小型公司没有 TPM（技术项目经理），只有大公司才会有专门的 TPM 去组织管理跨多个团队的项目。</p><p>如果我们把一个项目按照 WWHWW 拆分：</p><ul><li><strong>Why？</strong> 为什么要做？</li><li><strong>What？</strong> 项目的目标是什么？做成什么样？</li><li><strong>How？</strong> 项目要如何完成？技术方案、系统架构是什么？</li><li><strong>When？</strong> 项目何时可以交付？Roadmap 和计划是什么？</li><li><strong>Who？</strong> 安排谁来做这个项目？</li></ul><p>那么通常产品经理（PM）是负责解决 Why 和 What 的，解释清楚为什么要立项，要做成什么样。也就是我们通常说的立项和项目需求。</p><p>在确定需求后，工程经理（EM）就要负责去评估时间（When），安排人手（Who），和团队的工程师一起做出技术方案（How）并推动项目完成。通常 EM 只负责本团队的项目。</p><p>在大公司，一些复杂的项目需要多个团队一起协作，这种情况下单靠 PM 和 EM 是不够的，所以这时候通常会需要技术项目经理（TPM）的帮助，对于跨团队的大项目，TPM 和 PM 以及各个团队的 EM 一起协作，定义好 Roadmap（When），任务分解到各个团队（Who），解决项目中的问题，推动项目的执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown Syntax Guide</title>
    <link href="/shinyruotechtips/2024/01/c5d07596ae69/"/>
    <url>/shinyruotechtips/2024/01/c5d07596ae69/</url>
    
    <content type="html"><![CDATA[<p>This article offers a sample of basic Markdown syntax.</p><h1 id="Titles"><a href="#Titles" class="headerlink" title="Titles"></a>Titles</h1><p>As we started writing a markdown document, we need to add a title and some sub-headers.</p><p>Markdown supports two styles of headers, Setext and atx.</p><p>Setext-style headers are “underlined” using equal signs (for first-level headers) and dashes (for second-level headers). For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">This is an H1</span><br><span class="hljs-section">=============</span><br><br><span class="hljs-section">This is an H2</span><br><span class="hljs-section">-------------</span><br></code></pre></td></tr></table></figure><p>Any number of underlining &#x3D;’s or -’s will work.</p><p>Atx-style headers use 1-6 hash characters at the start of the line, corresponding to header levels 1-6. For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># This is an H1</span><br><br><span class="hljs-section">## This is an H2</span><br><br><span class="hljs-section">###### This is an H6</span><br></code></pre></td></tr></table></figure><p>Optionally, you may “close” atx-style headers. This is purely cosmetic — you can use this if you think it looks better. The closing hashes don’t even need to match the number of hashes used to open the header. (The number of opening hashes determines the header level.) :</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># This is an H1 #</span><br><br><span class="hljs-section">## This is an H2 ##</span><br><br><span class="hljs-section">### This is an H3 ######</span><br></code></pre></td></tr></table></figure><h1 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h1><p>Tables aren’t part of the core Markdown spec, but they are part of GFM (GitHub Markdown) and Markdown Here supports them.</p><p>Here is an example of table with the output below:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> Tables        </span>|<span class="hljs-string"> Are           </span>|<span class="hljs-string"> Cool  </span>|<br>|<span class="hljs-string"> ------------- </span>|<span class="hljs-string">:-------------:</span>|<span class="hljs-string"> -----:</span>|<br>|<span class="hljs-string"> col 3 is      </span>|<span class="hljs-string"> right-aligned </span>|<span class="hljs-string"> $1600 </span>|<br>|<span class="hljs-string"> col 2 is      </span>|<span class="hljs-string"> centered      </span>|<span class="hljs-string">   $12 </span>|<br>|<span class="hljs-string"> zebra stripes </span>|<span class="hljs-string"> are neat      </span>|<span class="hljs-string">    $1 </span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><p>Colons can be used to align columns.</p><p>The outer pipes (|) are optional, and you don’t need to make the raw Markdown line up prettily. You can also use inline Markdown.</p><p>Example:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">Markdown |<span class="hljs-string"> Less </span>|<span class="hljs-string"> Pretty</span><br><span class="hljs-string">--- </span>|<span class="hljs-string"> --- </span>|<span class="hljs-string"> ---</span><br><span class="hljs-string">*Still* </span>|<span class="hljs-string"> `renders` </span>|<span class="hljs-string"> **nicely**</span><br><span class="hljs-string">1 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> 3</span><br></code></pre></td></tr></table></figure><h1 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h1><p>Markdown supports two styles of links: inline and reference.</p><p>In both styles, the link text is delimited by [square brackets].</p><p>To create an inline link, use a set of regular parentheses immediately after the link text’s closing square bracket. Inside the parentheses, put the URL where you want the link to point, along with an optional title for the link, surrounded in quotes. For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">I&#x27;m an inline-style link</span>](<span class="hljs-link">https://www.google.com</span>)<br><br>[<span class="hljs-string">I&#x27;m an inline-style link with title</span>](<span class="hljs-link">https://www.google.com &quot;Google&#x27;s Homepage&quot;</span>)<br><br>[<span class="hljs-string">I&#x27;m a reference-style link</span>][<span class="hljs-symbol">arbitrary case-insensitive reference text</span>]<br><br>[<span class="hljs-string">I&#x27;m a relative reference to a repository file</span>](<span class="hljs-link">../blob/master/LICENSE</span>)<br></code></pre></td></tr></table></figure><p>Reference-style links use a second set of square brackets, inside which you place a label of your choosing to identify the link:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">This is [<span class="hljs-string">an example</span>][<span class="hljs-symbol">id</span>] reference-style link.<br></code></pre></td></tr></table></figure><p>You can optionally use a space to separate the sets of brackets:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">This is [an example] [id] reference-style link.<br></code></pre></td></tr></table></figure><p>Then, anywhere in the document, you define your link label like this, on a line by itself:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">id</span>]: <span class="hljs-link">http://example.com/ &quot;Optional Title Here&quot;</span><br></code></pre></td></tr></table></figure><p><strong>GitHub</strong> and <strong>GitBook</strong> supports URL autolinking. They will autolink standard URLs, so if you want to link to a URL (instead of setting link text), you can simply enter the URL and it will be turned into a link to that URL.</p><h1 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Inline</span><br><br>![<span class="hljs-string">Alternative text</span>](<span class="hljs-link">/path/to/img.jpg &quot;Optional title&quot;</span>)<br><br><span class="hljs-section"># Reference</span><br><br>![<span class="hljs-string">Alternative text</span>][<span class="hljs-symbol">id</span>]<br>[<span class="hljs-symbol">id</span>]: <span class="hljs-link">url/to/image &quot;Optional title&quot;</span><br></code></pre></td></tr></table></figure><p>As you may have noticed, images in Markdown are very similar to links. The difference is that:</p><ul><li>the square brackets must be prefixed with an exclamation mark and</li><li>inside they may have some alternative text. A description of the image, which is displayed if the image can’t be loaded.</li></ul><h1 id="Code-Blocks"><a href="#Code-Blocks" class="headerlink" title="Code Blocks"></a>Code Blocks</h1><p>Pre-formatted code blocks are used for writing about programming or markup source code. Rather than forming normal paragraphs, the lines of a code block are interpreted literally.</p><p>Here is an example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">This is a code block<br></code></pre></td></tr></table></figure><p>To produce a code block in Markdown, simply indent every line of the block by at least 4 spaces or 1 tab.</p><p>For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">This is a normal paragraph:<br><br><span class="hljs-code">    This is a code block.</span><br></code></pre></td></tr></table></figure><p>You can also create code block separated by:</p><pre><code class="hljs"><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### Inline <span class="hljs-keyword">code</span> blocks<br><br>Inline <span class="hljs-keyword">code</span> blocks can be written using: `<br><br>For example:<br><br>    This is a `<span class="hljs-keyword">inline</span> <span class="hljs-keyword">code</span> block`<br><br>### Syntax highlighting<br><br>You can define the language to be used for syntax highlighting by adding the name on the opening tag. Example:<br><br>    ```javascript<br>    var a = &#123;&#125;;<br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何配置一个DNS服务？</title>
    <link href="/shinyruotechtips/2022/12/1323966e29b7/"/>
    <url>/shinyruotechtips/2022/12/1323966e29b7/</url>
    
    <content type="html"><![CDATA[<p>今天在工作中遇到一个需要配置DNS Server的问题，记录一下。</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在配置DNS Server之前，我们要先了解，什么是DNS？我第一次接触DNS是在我家跨上了“信息高速路”之后的一天，那时候我还是一个小学生，一个周末我快乐地打开电脑准备进入4399小游戏来一把的时候，却发现无法连上互联网。我感到非常的意外，因为就在那时我还可以使用QQ和朋友们愉快地聊天。但是当时的我并不知道这个问题是什么原因，也并不会修复，后来还是给运营商的维修师傅打电话才把这个问题修复好了。直到后来我才知道是因为DNS出了问题，而QQ是直接使用IP地址来连接服务器，所以即使DNS失效，QQ也可以正常使用。</p><p>如果根据DNS的作用来说，DNS就是一个电话簿，在这个电话簿上记录了访问的网址对应的IP地址。对于DNS的产生和历史，此处不再赘述，我们只需要知道DNS协议运行在UDP协议上，使用端口号53。</p><h1 id="DNS是怎么工作的？"><a href="#DNS是怎么工作的？" class="headerlink" title="DNS是怎么工作的？"></a>DNS是怎么工作的？</h1><p>DNS系统采用的是分布式的解析方案，整个DNS架构是一种层次树状结构，这个树状结构称为DNS域名空间，如下图所示：</p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AADNS%E6%9C%8D%E5%8A%A1%EF%BC%9F/2022-12-20-21-32-00-image.png"></p><p><a href="https://root-servers.org/">Root Server Technical Operations Association (root-servers.org)</a>如果有兴趣的话，在这个网站上可以查看所有根域服务器。</p><p>主机名和域名结合构成了FQDN<a href="https://en.wikipedia.org/wiki/Fully_qualified_domain_name">Fully qualified domain name - Wikipedia</a>，比如<a href="http://www.bing.com.就是一个fqdn./">www.bing.com.就是一个FQDN。</a></p><blockquote><p>注1：FQDN只能包含26个英文字母、“0-9”十个数字和“-”英文中的连接号，且开头和结尾不能含有这个连接号。中文域名包含两到十五个汉字之间的字词或词组。域名中不能包含空格及符号如？&#x2F;；：@#$%^~_&#x3D;+&amp;。等。</p></blockquote><blockquote><p>注2: 每个域名的最后面有一个点号“.”表示根域名，实际使用的时候为了方便省略掉。</p></blockquote><h1 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h1><p>整个DNS的域名解析过程是什么样的呢？</p><h5 id="1-本地缓存"><a href="#1-本地缓存" class="headerlink" title="1.本地缓存"></a>1.本地缓存</h5><p>当我们在浏览器中输入一个域名的时候，首先会去浏览器的 dns 缓存中去查询是否有对应记录。如果查询到记录就可以直接返回 ip 地址，完成解析。同上，如果浏览器没有对应的缓存，就去查询操作系统的缓存。</p><h5 id="2-hosts"><a href="#2-hosts" class="headerlink" title="2.hosts"></a>2.hosts</h5><p>当缓存中没有记录的时候，去检查本地的hosts(C:\Windows\System32\drivers\etc\hosts)文件是否有这个网址的映射关系.</p><h5 id="3-本地DNS服务器"><a href="#3-本地DNS服务器" class="headerlink" title="3.本地DNS服务器"></a>3.本地DNS服务器</h5><p>一般来说，本地DNS一般本地的互联网运营商提供，由DHCP自动分配，当然也可以由使用者手动配置。</p><img src="../imgs/如何配置一个DNS服务？/2022-12-20-22-17-26-image.png" title="" alt="" width="383"><p>当hosts没有对应映射时，查找本地DNS服务器缓存。如果该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p><h5 id="4-根域名-x2F-上级服务器"><a href="#4-根域名-x2F-上级服务器" class="headerlink" title="4.根域名&#x2F;上级服务器"></a>4.根域名&#x2F;上级服务器</h5><p>这里根据本地DNS服务器是否设置了转发器，有两种情况。</p><p><strong>未启用转发模式：</strong> 本地DNS把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(baidu.com)给本地DNS服务器，直到找到主机。</p><p><strong>启用转发模式：</strong> 此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p><p>这就是DNS系统的作用：</p><p>    正向解析：根据主机名称（域名）查找对应的IP地址</p><p>    反向解析：根据IP地址查找对应的主机域名</p><p>如果想要更深入地理解DNS的工作原理，我们可以用Wireshark抓一个DNS请求包，并对它的内容进行分析。</p><p>以对<a href="http://www.biying.com的访问作为例子：">www.biying.com的访问作为例子：</a></p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AADNS%E6%9C%8D%E5%8A%A1%EF%BC%9F/2022-12-22-21-29-52-image.png"></p><p>可以看到，访问<a href="http://www.biying.com总共产生了四条数据,两次dns请求,第一次查询www.biying.com域名对应的ipv4地址,第二次查询www.biying.com域名对应的ipv6地址./">www.biying.com总共产生了四条数据，两次DNS请求，第一次查询www.biying.com域名对应的IPv4地址，第二次查询www.biying.com域名对应的IPv6地址。</a></p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AADNS%E6%9C%8D%E5%8A%A1%EF%BC%9F/2022-12-22-21-37-03-image.png"></p><p><strong>报文分析</strong>：</p><p>可以看到，网络传输层使用 UDP 协议，端口号为 53</p><h4 id="DNS报文基础结构部分"><a href="#DNS报文基础结构部分" class="headerlink" title="DNS报文基础结构部分"></a><strong>DNS报文基础结构部分</strong></h4><p>每个字段含义如下。</p><ul><li>事务 ID（Transaction ID）：DNS 报文的 ID 标识。对于请求报文和其对应的应答报文，该字段的值是相同的。通过它可以区分 DNS 应答报文是对哪个请求进行响应的。</li><li>标志（Flags）：DNS 报文中的标志字段。</li><li>问题计数（Questions）：DNS 查询请求的数目。</li><li>回答资源记录数（Answers RRs）：DNS 响应的数目。</li><li>权威名称服务器计数（Authority RRs）：权威名称服务器的数目。</li><li>附加资源记录数（Additional RRs）：额外的记录数目（权威名称服务器对应 IP 地址的数目）。</li></ul><p>   其中Flags字段中每个字段的含义如下：</p><ul><li>QR（Response）：查询请求&#x2F;响应的标志信息。查询请求时，值为 0；响应时，值为 1。</li><li>Opcode：操作码。其中，0 表示标准查询；1 表示反向查询；2 表示服务器状态请求。</li><li>AA（Authoritative）：授权应答，该字段在响应报文中有效。值为 1 时，表示名称服务器是权威服务器；值为 0 时，表示不是权威服务器。</li><li>TC（Truncated）：表示是否被截断。值为 1 时，表示响应已超过 512 字节并已被截断，只返回前 512 个字节。</li><li>RD（Recursion Desired）：期望递归。该字段能在一个查询中设置，并在响应中返回。该标志告诉名称服务器必须处理这个查询，这种方式被称为一个递归查询。如果该位为 0，且被请求的名称服务器没有一个授权回答，它将返回一个能解答该查询的其他名称服务器列表。这种方式被称为迭代查询。</li><li>RA（Recursion Available）：可用递归。该字段只出现在响应报文中。当值为 1 时，表示服务器支持递归查询。</li><li>Z：保留字段，在所有的请求和应答报文中，它的值必须为 0。</li><li>rcode（Reply code）：返回码字段，表示响应的差错状态。<ul><li>当值为 0 时，表示没有错误；</li><li>当值为 1 时，表示报文格式错误（Format error），服务器不能理解请求的报文；</li><li>当值为 2 时，表示域名服务器失败（Server failure），因为服务器的原因导致没办法处理这个请求；</li><li>当值为 3 时，表示名字错误（Name Error），只有对授权域名解析服务器有意义，指出解析的域名不存在；</li><li>当值为 4 时，表示查询类型不支持（Not Implemented），即域名服务器不支持查询类型；</li><li>当值为 5 时，表示拒绝（Refused），一般是服务器由于设置的策略拒绝给出应答，如服务器不希望对某些请求者给出应答，，或者服务器不希望进行某些操作（比如区域传送zone transfer）；</li><li>6-15 保留值，暂时未使用。</li></ul></li></ul><p><strong>DNS报文问题查询部分</strong><br>每个字段含义如下：</p><ul><li>查询名（Name）：一般为要查询的域名胡总和邮件服务器，有时也会是 IP 地址，用于反向查询。</li><li>查询类型（Type）：DNS 查询请求的资源类型。通常查询类型为 A （Address的缩写）类型，表示由域名获取对应的 IP4 地址。（更多类型如 AAAA，CANME，SOA，PTR，NS 等）</li><li>查询类（Class）：地址类型，在设计DNS方案的时候，DNS在除了互联网之外的其他网络中的情况也被考虑到了，所以Class用来识别网络类型，不过，如今除了互联网没有其他的网络了，所以该值为IN。<br>那么，对于上面报文内容，翻译过后的意思就是，“该报文为标准查询(Opcode&#x3D;0)请求(QR&#x3D;1)报文，向本地域名服务器请求查询，发起请求内容为’获取<a href="http://www.biying.com'所对应的ipv4地址,期待本地域名服务器递归查询(rd=1)请求./">www.biying.com&#39;所对应的IPv4地址，期待本地域名服务器递归查询(RD=1)请求。</a></li></ul><p><strong>TODO</strong> 配置DNS服务的实例</p>]]></content>
    
    
    
    <tags>
      
      <tag>-DNS -网络技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Docker到OpenShift（二）</title>
    <link href="/shinyruotechtips/2022/12/3ed6afbd27f8/"/>
    <url>/shinyruotechtips/2022/12/3ed6afbd27f8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Kubernetes与Docker的关系"><a href="#1-Kubernetes与Docker的关系" class="headerlink" title="1.Kubernetes与Docker的关系"></a>1.Kubernetes与Docker的关系</h1><p>在第一次接触到K8s的时候，我以为这个技术和Docker有一定的关系，毕竟一个的logo是驮着集装箱的鲸鱼，而另一个是船的舵轮，都是在虚拟化技术的大海中乘波驶浪的实现方式。</p><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%BA%8C%EF%BC%89/cac5432e5ba26a36ca6d41e9ad6f1ca8d0e0970c.png"></p><p>不过在对K8s有更多的了解后，我认为这两者并不能放在一个维度上进行讨论，两者所面向和解决的问题并不相同。Docker是非常流行的Linux容器解决方案，这我们在之前的文章中已经有了一定的了解。而K8s是一个容器编排的解决方案，主要面向的是集群管理，K8s支持对接多种容器，Docker并不是K8s对容器的唯一选择，比如K8s还支持Apache开源的Mesos容器等等。只要容器实现了K8s容器运行时的接口约定，都可以被K8s调度。</p><p>我认为某种意义上，是容器的大规模使用，引入了新的问题，从而催生了容器的编排技术，把许多Container抽象，对外部使用者来说，并不关心容器内部的应用是如何运行的，而是关注以下问题：</p><ul><li><p>如何部署、调度、管理容器中的应用？</p></li><li><p>如何在升级程序的时候不中断对外的服务？</p></li><li><p>容器里的程序是否是正常运行的？</p></li><li><p>如何方便地根据业务去调整容器里的应用？</p></li></ul><p>其实Docker的公司也推出过他们的容器集群管理方案Docker Swarm，某种意义上是K8s的竞品，但是在IT行业的生产中并没有流行起来，究其原因可能有以下几点：</p><ul><li><p>该方案和Docker绑定的程度太深，Docker本身是非常优秀的container方案，但是Swarm本身的功能非常有限，而且在刚推出的时候并不成熟</p></li><li><p>Google在推出K8s的时候，已经是一个比较成熟的方案了，并且归功于谷歌在大规模集群管理上的经验，谷歌给出的解决方案是非常高屋建瓴并且实用的</p></li><li><p>IT行业的规则是赢者通吃，使用的越为广泛的方案会有更加成熟的社区和公司去推动建设。</p></li></ul><p>虽然K8s的配置更为复杂，但是它同时提供了更为灵活的部署方案，K8s的自动管理生命周期、自动恢复、模块化的架构设计，都是在生产中更具有实用价值的。如果我们想要学习K8s，实际上并不一定要会Docker。学 K8s 更多是让开发的服务能运行在 K8s 集群上，依托 K8s 集群管理、调度的能力让服务变得更具鲁棒性、更便于调整。对于Docker，需要有一个概念上的认知，如果有需要，再去学习就可以了。</p><h1 id="2-K8s的起源"><a href="#2-K8s的起源" class="headerlink" title="2.K8s的起源"></a>2.K8s的起源</h1><p>众所周知，K8s起源于Google的开源，不过K8s的前身，在Google内部真正使用的系统叫做Borg。据说Google在Linux内核还没有CGroup和容器的情况下，造出了同样的东西。也有传言说Google将Brog中的一些边缘技术通过Golang来实现，变成了Kubernetes。当然，Google的说法是K8s吸取了Borg的优秀理念，Google的开源可谓是“纯粹的奉献”。像Google这样的IT行业领头公司，有许多开发的项目，当然也有很多因为各种原因不再继续进行维护的项目，<a href="https://killedbygoogle.com/">Google Graveyard - Killed by Google</a>这个网站记录了Google曾经开发，现在已经是Dead Project的项目。有趣的是，该网站的作者曾经被Google聘请，不过作者本人拒绝了。不得不说，通过开源建立生态，培养用户，吸引企业用户上Google云去获得非阉割版本的性能是很高明的商业策略，这就是巨头的玩法。</p><p>K8s提供了什么？我认为K8s最重要的一点是能够做到把容器部署为服务，这也是IT行业一直说的XaaS（ CaaS、laaS、PaaS）。K8s提供了Pod、Service等机制，帮助用户构建跨多个容器的应用服务、跨集群调度、扩展这些容器，并长期持续管理这些容器的运行健康状况；除此之外，它还可以根据用户设定的策略来自动管理用户的服务。</p><p>如果作为服务的使用者来看，我们关心的是什么？我认为主要是服务的质量与可靠性，也就是说要保持服务的高可用性，这也是2B的IT服务提供商最需要做到的事情。假设有一个服务通过Pod1运行在机器1上，这时候K8s探测到机器1有问题或者处于离线状态，那么K8s就会把这个Pod在另一台机器2上重新拉起，并继续提供对应的服务，看起来这样的方案非常的合理。然而，请思考这样一个问题：我们如何确定机器1确实没有在工作了？在这里我想引入一个电脑领域的假想实验：<a href="https://zh.wikipedia.org/wiki/%E4%B8%A4%E5%86%9B%E9%97%AE%E9%A2%98">Two Generals’ Problem</a>，只有当收到回复并且再次对回复的内容做出回应之后，我们才认为信息是可靠的。然而对于机器1来说，信息显然已经不能再传递，我们应该如何保证机器1上的Pod1没有继续对数据进行修改呢？在分布式集群系统中这是一个非常常见的需要进行处理的问题，这就是“脑裂”（split-brain）现象。我们需要保证新的数据服务启动后，确保旧的服务不在能对数据进行处理或者访问修改，从而保证数据的完整性，这个机制叫Fencing。怎么去解决这个问题，我想IT行业应该已经有许多成熟的方案，而我并不了解，也不是在这里我想要去探讨的问题。</p><p>提到K8s，不得不提的就是“云原生”这个概念。</p><p>TBD</p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Docker到OpenShift（一）</title>
    <link href="/shinyruotechtips/2022/12/4757bbfdf288/"/>
    <url>/shinyruotechtips/2022/12/4757bbfdf288/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我们还是从最流行的也是最为大众熟知的容器技术产品 Docker 讲起。</p><p>在 2013 年的 PyCon 会议上，Solomon Hykes 利用“闪电演讲”环节，做了题为《The future of Linux Containers》的报告。在B站上有用户上传了当年的报告视频，如果你有兴趣的话可以看一下 <a href="https://www.bilibili.com/video/BV1114y1h7qx">Docker 的诞生</a> 。因为这个环节给每位演讲者的演讲时间只有五分钟，Solomon 只能非常仓促地展示了 docker，期间他还把 world 拼错了，最后还因为超时被主持人请下了台。</p><p>五分钟的演讲时间非常短暂，但他提到了很多新概念：容器、镜像、进程隔离等。这场会议过后，很多云服务厂商意识到这项技术可能会给应用打包、部署、运维提供很多便利，Docker 就这样流行了起来。最终发展到如今的 Kubernetes、服务网格等技术（应用）。</p><p>接下来我们尝试复现一下 Solomon 在 PyCon US 2013 上的演示：</p><p>本文中的操作均在Windows Docker Desktop 命令行下执行。</p><p>首先使用 <code>docker pull</code> 命令拉取一个 <code>busybox</code> 镜像（image）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull busybox<br></code></pre></td></tr></table></figure><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-22-51-47-image.png"></p><p>我们稍后再解释 <code>docker pull</code> 的输出</p><p>然后执行下面的命令，查看本地的所有镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images<br></code></pre></td></tr></table></figure><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-22-52-28-image.png"></p><p>可以看到名为 <code>busybox</code> 的镜像已经被拉取到本地了</p><p>接下来我们就可以利用这个镜像启动容器了，我们要在容器里执行一个 <code>echo</code> 命令，让它输出一个字符串 <code>hello world</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run busybox echo &quot;hello world!&quot;<br></code></pre></td></tr></table></figure><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-22-56-59-image.png"></p><p>最后我们再使用 <code>docker ps</code> 命令查看所有容器，我们会在列表中找到我们刚才启动的容器，它的状态是 Exited （因为 <code>echo</code> 命令已经执行完毕，容器无事可做就自动退出了）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps -a<br></code></pre></td></tr></table></figure><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-22-58-11-image.png"></p><h1 id="1-Docker-架构"><a href="#1-Docker-架构" class="headerlink" title="1. Docker 架构"></a>1. Docker 架构</h1><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-22-59-59-image.png"></p><p><a href="https://docs.docker.com/get-started/overview/">Docker 文档</a>中的这张图描述了 Docker 整套应用的角色和工作流程。</p><p>Docker 是典型的 C&#x2F;S 架构（客户端&#x2F;服务端）的应用。刚才我们使用的 docker 命令实际上是客户端（Docker Client），它会与 Docker Engine 的后台服务 Docker Daemon 通信，向它发送命令。Docker 镜像存储在远端的 Docker Registry 镜像仓库中。值得一提的是，使用 docker 命令并不能直接访问镜像仓库，它只能与 Docker Daemon 通信，告诉 Daemon 自己想要做什么，然后让 Daemon 完成操作并返回结果。</p><p>简要总结一下：</p><ol><li>docker client 是命令行工具，是我们和 Docker Daemon 之间的中间人，它通过 build、pull、run、ps 等命令向 Daemon 发送请求</li><li>docker daemon 是 Docker Engine 的后台服务，负责管理容器和镜像；它和镜像仓库一同完成各种操作</li></ol><p>Docker 官方还提供了一个 hello-world 镜像，向你展示 Docker 的实际工作流程，我们只需要运行下面的命令就能查看它运行的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run hello-world<br></code></pre></td></tr></table></figure><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-23-01-00-image.png"></p><p>以上内容讲的大概就是说：</p><ol><li>docker 客户端与 docker daemon 通信，发送“运行 hello-world”的请求</li><li>Docker daemon 在本地镜像库找不到名为 “hello-world” 的镜像，就从 Docker Hub 镜像仓库拉取这个镜像</li><li>Docker daemon 通过 “hello-world” 镜像创建了一个容器，这个容器的输出就是你现在阅读的内容</li><li>Docker daemon 将输出传递给 docker 客户端，然后客户端将这些输出打印到终端上</li></ol><p>到这里我们探索 Docker 架构的初步了解就结束了，但还有值得一提的一些点：</p><p><strong>本地的 Docker 的客户端和 Docker daemon 如何通信？</strong></p><p>我们可以使用 <code>docker context ls</code> 命令来查看 docker 客户端在与哪个 Docker daemon 通信：</p><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-23-02-42-image.png"></p><p>可以看到 <code>DOCKER ENDPOINT</code> 是 <code>npipe:////./pipe/docker_engine</code> ，对于windows docker中的ENDPOINT是如何实现的，我不太了解。但是在unix系统中，ENDPOINT是一个 unix 套接字，很多时候，本机进程进行进程间通信时就使用 Unix 套接字，它本质上还是一个文件，这就是 Unix 的其中一条哲学：“一切皆文件”。</p><p><strong>什么是busybox</strong></p><p>busybox 是一个集成了三百多个最常用Linux命令和工具的软件，包含 echo、ls 等常用命令，体积很小，很适合测试任务或者嵌入式系统。</p><p><strong>为啥是 C&#x2F;S 架构</strong></p><p>C&#x2F;S架构更重要的是实现了功能分离，利于分布式应用，不限于单机，比如运行一个docker daemon，然后多个客户端都向这个服务器发命令。</p><h1 id="2-什么是容器"><a href="#2-什么是容器" class="headerlink" title="2. 什么是容器"></a>2. 什么是容器</h1><p>广义上来说：容器技术 &#x3D; 动态的容器（狭义的容器） + 静态的镜像 + 远端的仓库。接下来我们就从狭义的容器开始探究容器技术。</p><h2 id="2-1-容器：被隔离的进程"><a href="#2-1-容器：被隔离的进程" class="headerlink" title="2.1 容器：被隔离的进程"></a>2.1 容器：被隔离的进程</h2><p>容器（Container）的字面意义是集装箱，而 Docker 的字面意义是码头工人。集装箱的作用是封装各种货物使其成为一个标准的运载单位，方便统计、存储、运输…相比运送散装货物，集装箱隔离了内外环境，防止集装箱内的货物影响外界，或者被外界影响。</p><p>在计算机世界里容器也发挥着同样的作用，它将进程与环境隔离开，让进程和系统的其他部分互不影响。</p><p>我们可以尝试启动一个 CentOS的容器，并打开它的 shell 尝试运行几个命令。我的宿主机运行的是 Windows —— 也就是说，我们要在Windows操作系统上运行一个 CentOS 操作系统的容器：</p><p>我们在容器内查看系统信息，以及正在运行的进程</p><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-23-14-08-image.png"></p><p>而对于我们的宿主机里，显然属于不同的操作系统，在系统进程里也看不到docker中运行的进程<img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-23-15-24-image.png"></p><p>在容器内运行的程序完全看不到宿主机的痕迹，两个操作系统像是被“隔离”了。也就是说，<strong>容器是一个特殊的运行环境，在其中运行的进程只能访问到有限的资源和信息，无法对外界施加影响（当然不是绝对的“无法”）。</strong></p><p>容器的隔离有两层含义：</p><h3 id="运行环境隔离"><a href="#运行环境隔离" class="headerlink" title="运行环境隔离"></a>运行环境隔离</h3><p>出于对系统安全的考虑，在计算机世界我们要对进程进行“隔离”。在 Linux 操作系统中，一个不受约束的应用程序是十分危险的：他可以访问任何文件，窃取重要信息，影响正常运行的程序，甚至把系统搞瘫痪。</p><p>利用容器技术，我们可以在系统中创造出一个沙箱（sandbox），给进程一个限定的运行环境，告诉它：你只许在这个环境内自由活动，但是不允许越界。这样我们就能保障容器外系统的安全。</p><p>这样做还有一个优点就是我们能够更方便地管理应用程序的依赖项，防止在同一台机器上运行的应用程序因为依赖项冲突而无法正常工作。</p><h3 id="系统资源隔离"><a href="#系统资源隔离" class="headerlink" title="系统资源隔离"></a>系统资源隔离</h3><p>容器技术还可以为应用程序加上资源隔离。计算机里有各种各样的资源，CPU、内存、硬盘、网卡，这些资源是有限的，考虑到成本，也不允许某个应用程序无限制地占用大量系统资源。</p><p>我们可以为容器分配限定的系统资源，比如只能使用双核 CPU、2 GB 内存… 这样就可以避免进程过度消耗系统资源，让各个进程充分利用计算机硬件，同时提供稳定可靠的服务。</p><h2 id="2-2-与虚拟机的区别"><a href="#2-2-与虚拟机的区别" class="headerlink" title="2.2 与虚拟机的区别"></a>2.2 与虚拟机的区别</h2><p>容器和虚拟机都使用虚拟化技术，但它们所在的层次（也就是说隔离程度）不同，我们可以通过 Docker 文档里的这张图来了解：</p><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-23-20-25-image.png"></p><p>请注意，图示中容器并不运行在 Docker 之上，Docker 只是辅助建立隔离环境，让容器基于 Linux 操作系统运行</p><ol><li>容器和虚拟机的目的都是隔离资源，保证系统安全，尽量提高资源使用率</li><li>虚拟机通过 Hypervisor（虚拟机软件，KVM 等）将一台物理设备虚拟成多台逻辑设备，这些逻辑设备彼此独立，并且需要在虚拟硬件上安装操作系统才能使用；硬件虚拟化和操作系统会消耗大量的系统资源，但是它的好处就是隔离程度比较高</li><li>容器则直接利用操作系统和硬件，比虚拟机少了一层，自然会节约 CPU 和内存这些资源，比虚拟机更加轻量，对系通过资源的利用也就更加高效；当然因为多个容器共用操作系统的内核，应用程序的隔离程度就没有那么高了</li></ol><p>Ubuntu 虚拟机的启动时间可能是十几秒甚至数十秒，而一个 Ubuntu 容器只需要一秒左右便可以启动，更不用说它的镜像大小相较于完整的操作系统更小（只有70多MB），同时运行上百个容器也不在话下。</p><p>当然，这两种技术是可以同时使用的，我们可以在一台服务器上虚拟多个操作系统，然后在虚拟机中使用容器来快速运行应用程序。</p><h2 id="2-3-容器隔离的实现"><a href="#2-3-容器隔离的实现" class="headerlink" title="2.3 容器隔离的实现"></a>2.3 容器隔离的实现</h2><p>Docker 的隔离依靠 Linux 提供的三种技术 <code>namespace</code> <code>cgroup</code> <code>chroot</code> ：</p><ol><li><code>namespace</code> 用于创建独立的文件系统 主机名 进程号 还有网络等资源</li><li><code>cgroup</code> 实现对进程的 CPU、内存等资源进行配额限制</li><li><code>chroot</code> 则限制进程访问原有的文件系统，不过现在有更加现代化的 pivot_root，这里只是为了解释原理</li></ol><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>namespace 是 Linux 内核的一项功能，该功能对内核资源进行隔离，使得容器中的进程都可以在单独的命名空间中运行，并且只可以访问当前容器命名空间的资源。namespace 可以隔离进程 ID、主机名、用户 ID、文件名、网络访问和进程间通信等相关资源。</p><p>Docker 主要利用下面几种命名空间：</p><ol><li>pid namespace：用于隔离进程 ID</li><li>net namespace：网络虚拟化的基石，用于隔离网络接口，在虚拟的 net namespace 内用户可以拥有自己独立的 IP、路由、端口等</li><li>mnt namespace：文件系统挂载点隔离</li><li>ipc namespace：信号量、消息队列和共享内存的隔离</li><li>uts namespace：主机名和域名的隔离</li></ol><h3 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a>Cgroup</h3><p>Cgroups 是一个 Linux 内核功能，可以限制和隔离进程的资源使用情况（CPU、内存、磁盘 I&#x2F;O、网络等）。在容器的实现中，Cgroups 通常用来限制容器的 CPU 和内存等资源的使用。</p><h3 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h3><p>chroot 针对正在运作的软件进程和它的子进程，改变它外显的根目录。一个运行在这个环境下，经由 chroot 设置根目录的程序，不能够对这个指定根目录之外的文件进行访问动作，不能读取，也不能更改它的内容。</p><p>简单来说就是“伪造”一个文件系统来欺骗容器中的进程。用操作系统镜像文件挂载到容器进程的根目录下，变成容器的rootfs，和真实系统目录一模一样。</p><p>综合运用这三种技术，一个具备完善隔离特性的容器就出现了。</p><h2 id="2-4-镜像"><a href="#2-4-镜像" class="headerlink" title="2.4 镜像"></a>2.4 镜像</h2><p>和其他镜像一样，容器技术中的“镜像”也是只读的，它以标准格式存储了一系列的文件，然后在需要的时候再从中提取出数据运行起来。因为容器是由操作系统动态创建的，那么必然就可以用一种办法把它的初始环境给固化下来，保存成一个静态的文件，方便存放、传输、版本化管理。</p><p>镜像是容器的静态形式，它<strong>打包了应用程序的所有运行依赖项</strong>，方便保存和传输。使用容器技术运行镜像，就形成了动态的容器，由于镜像只读不可修改，所以应用程序的运行环境总是一致的。</p><p>而容器化的应用就是指以镜像的形式打包应用程序，然后在容器环境里从镜像启动容器。</p><p>之前我们运行的命令 <code>docker pull busybox</code> ，就是获取了一个打包了 busybox 应用的镜像，里面固化了 busybox 程序和它所需的完整运行环境。</p><p>而 <code>docker run busybox echo hello world</code> ，就是提取镜像里的各种信息，运用 namespace、cgroup、chroot 技术创建出隔离环境，然后再运行 busybox 的 echo 命令，输出 hello world 的字符串。</p><p>这两个步骤，由于是基于标准的 Linux 系统调用和只读的镜像文件，所以，无论是在哪种操作系统上，或者是使用哪种容器实现技术，都会<strong>得到完全一致的结果</strong>。</p><p>所谓的“容器化的应用”，或者“应用的容器化”，就是指<strong>应用程序不再直接和操作系统打交道，而是封装成镜像，再交给容器环境去运行</strong>。</p><p>可以说，镜像就是静态的应用容器，容器就是动态的应用镜像，两者相互转化。</p><h3 id="镜像的内部机制"><a href="#镜像的内部机制" class="headerlink" title="镜像的内部机制"></a>镜像的内部机制</h3><p>镜像就是一个打包文件，里面包含了应用程序还有它运行所依赖的环境，例如文件系统、环境变量、配置参数等等。</p><p>容器镜像内部并不是一个平坦的结构，而是由许多的镜像层组成的，每层都是只读不可修改的一组文件，相同的层可以在镜像之间共享，然后多个层像搭积木一样堆叠起来，再使用一种叫“Union FS 联合文件系统”的技术把它们合并在一起，就形成了容器最终看到的文件系统。你可以用命令 docker inspect 来查看镜像的分层信息。</p><p>Docker 会检查是否有重复的层，如果本地已经存在就不会重复下载，如果层被其他镜像共享就不会删除，这样就可以节约磁盘和网络成本。</p><p>如果还想了解 UnionFS，可以参考这篇文章：<a href="https://www.cnblogs.com/bjlhx/p/13202505.html">结合docker命令理解镜像</a></p><h2 id="2-5-远端镜像仓库"><a href="#2-5-远端镜像仓库" class="headerlink" title="2.5 远端镜像仓库"></a>2.5 远端镜像仓库</h2><p>镜像仓库就非常简单了，顾名思义，它是存储镜像的地方。在构建好镜像后，开发者们通常会将镜像上传到 Registry 服务器上进行保存。这样可以保证不会因本机故障而导致镜像丢失，同时，其他开发者也能很方便地通过网络方式下载公开镜像仓库中的镜像，真正做到“开箱即用”。</p><p>总而言之，Linux世界的技术创新大多都是发源于内核，经过一层层的面向用户的抽象和封装，这就是所谓的万变不离其宗。比如传统的网络虚拟化和BGP，在容器这个新瓶子里焕发第二春，软件技术、IT行业是快速迭代的，但是维持软件系统运转的、最本质的部分并不会轻易改变。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
